/* automatically generated by rust-bindgen */

pub const RC_BTN_STATE_PRESSED: u32 = 1;
pub const RC_BTN_STATE_RELEASED: u32 = 0;
pub const RC_BTN_POLARITY_NORM_HIGH: u32 = 1;
pub const RC_BTN_POLARITY_NORM_LOW: u32 = 0;
pub const RC_BTN_DEBOUNCE_DEFAULT_US: u32 = 2000;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201605;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 24;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const RC_MAX_DSM_CHANNELS: u32 = 9;
pub const GPIOHANDLE_REQUEST_INPUT: u32 = 1;
pub const GPIOHANDLE_REQUEST_OUTPUT: u32 = 2;
pub const GPIOHANDLE_REQUEST_ACTIVE_LOW: u32 = 4;
pub const GPIOHANDLE_REQUEST_OPEN_DRAIN: u32 = 8;
pub const GPIOHANDLE_REQUEST_OPEN_SOURCE: u32 = 16;
pub const GPIOEVENT_REQUEST_RISING_EDGE: u32 = 1;
pub const GPIOEVENT_REQUEST_FALLING_EDGE: u32 = 2;
pub const GPIOEVENT_REQUEST_BOTH_EDGES: u32 = 3;
pub const RC_GPIOEVENT_ERROR: i32 = -1;
pub const RC_GPIOEVENT_TIMEOUT: u32 = 0;
pub const RC_GPIOEVENT_RISING_EDGE: u32 = 1;
pub const RC_GPIOEVENT_FALLING_EDGE: u32 = 2;
pub const I2C_MAX_BUS: u32 = 5;
pub const I2C_BUFFER_SIZE: u32 = 128;
pub const RC_MOTOR_DEFAULT_PWM_FREQ: u32 = 25000;
pub const _PTHREAD_H: u32 = 1;
pub const _ENDIAN_H: u32 = 1;
pub const __LITTLE_ENDIAN: u32 = 1234;
pub const __BIG_ENDIAN: u32 = 4321;
pub const __PDP_ENDIAN: u32 = 3412;
pub const __BYTE_ORDER: u32 = 1234;
pub const __FLOAT_WORD_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const _BITS_BYTESWAP_H: u32 = 1;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _SCHED_H: u32 = 1;
pub const __time_t_defined: u32 = 1;
pub const __timespec_defined: u32 = 1;
pub const SCHED_OTHER: u32 = 0;
pub const SCHED_FIFO: u32 = 1;
pub const SCHED_RR: u32 = 2;
pub const __defined_schedparam: u32 = 1;
pub const __CPU_SETSIZE: u32 = 1024;
pub const _TIME_H: u32 = 1;
pub const _BITS_TIME_H: u32 = 1;
pub const CLOCK_REALTIME: u32 = 0;
pub const CLOCK_MONOTONIC: u32 = 1;
pub const CLOCK_PROCESS_CPUTIME_ID: u32 = 2;
pub const CLOCK_THREAD_CPUTIME_ID: u32 = 3;
pub const CLOCK_MONOTONIC_RAW: u32 = 4;
pub const CLOCK_REALTIME_COARSE: u32 = 5;
pub const CLOCK_MONOTONIC_COARSE: u32 = 6;
pub const CLOCK_BOOTTIME: u32 = 7;
pub const CLOCK_REALTIME_ALARM: u32 = 8;
pub const CLOCK_BOOTTIME_ALARM: u32 = 9;
pub const CLOCK_TAI: u32 = 11;
pub const TIMER_ABSTIME: u32 = 1;
pub const __clock_t_defined: u32 = 1;
pub const __clockid_t_defined: u32 = 1;
pub const __timer_t_defined: u32 = 1;
pub const TIME_UTC: u32 = 1;
pub const _XLOCALE_H: u32 = 1;
pub const _BITS_PTHREADTYPES_H: u32 = 1;
pub const __SIZEOF_PTHREAD_ATTR_T: u32 = 36;
pub const __SIZEOF_PTHREAD_MUTEX_T: u32 = 24;
pub const __SIZEOF_PTHREAD_MUTEXATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_COND_T: u32 = 48;
pub const __SIZEOF_PTHREAD_COND_COMPAT_T: u32 = 12;
pub const __SIZEOF_PTHREAD_CONDATTR_T: u32 = 4;
pub const __SIZEOF_PTHREAD_RWLOCK_T: u32 = 32;
pub const __SIZEOF_PTHREAD_RWLOCKATTR_T: u32 = 8;
pub const __SIZEOF_PTHREAD_BARRIER_T: u32 = 20;
pub const __SIZEOF_PTHREAD_BARRIERATTR_T: u32 = 4;
pub const __have_pthread_attr_t: u32 = 1;
pub const __PTHREAD_SPINS: u32 = 0;
pub const __PTHREAD_RWLOCK_ELISION_EXTRA: u32 = 0;
pub const _BITS_SETJMP_H: u32 = 1;
pub const PTHREAD_ONCE_INIT: u32 = 0;
pub const PTHREAD_BARRIER_SERIAL_THREAD: i32 = -1;
pub const RC_MPU_DEFAULT_I2C_ADDR: u32 = 104;
pub const RC_MPU_ALT_I2C_ADDR: u32 = 105;
pub const TB_PITCH_X: u32 = 0;
pub const TB_ROLL_Y: u32 = 1;
pub const TB_YAW_Z: u32 = 2;
pub const QUAT_W: u32 = 0;
pub const QUAT_X: u32 = 1;
pub const QUAT_Y: u32 = 2;
pub const QUAT_Z: u32 = 3;
pub const DEG_TO_RAD: f64 = 0.0174532925199;
pub const RAD_TO_DEG: f64 = 57.295779513;
pub const MS2_TO_G: f64 = 0.10197162129;
pub const G_TO_MS2: f64 = 9.80665;
pub const DSM_HEADER_PIN: u32 = 30;
pub const GPS_HEADER_PIN_3: u32 = 2;
pub const GPS_HEADER_PIN_4: u32 = 3;
pub const UART1_HEADER_PIN_3: u32 = 14;
pub const UART1_HEADER_PIN_4: u32 = 15;
pub const SPI_HEADER_PIN_3: u32 = 112;
pub const SPI_HEADER_PIN_4: u32 = 111;
pub const SPI_HEADER_PIN_5: u32 = 110;
pub const CAPE_SPI_PIN_6_SS1: u32 = 113;
pub const CAPE_SPI_PIN_6_SS2: u32 = 49;
pub const BLUE_SPI_PIN_6_SS1: u32 = 29;
pub const BLUE_SPI_PIN_6_SS2: u32 = 7;
pub const BLUE_GP0_PIN_3: u32 = 57;
pub const BLUE_GP0_PIN_4: u32 = 49;
pub const BLUE_GP0_PIN_5: u32 = 116;
pub const BLUE_GP0_PIN_6: u32 = 113;
pub const BLUE_GP1_PIN_3: u32 = 98;
pub const BLUE_GP1_PIN_4: u32 = 97;
pub const RC_SERVO_CH_MIN: u32 = 1;
pub const RC_SERVO_CH_MAX: u32 = 8;
pub const RC_SERVO_CH_ALL: u32 = 0;
pub const RC_ESC_DEFAULT_MIN_US: u32 = 1000;
pub const RC_ESC_DEFAULT_MAX_US: u32 = 2000;
pub const RC_ESC_DJI_MIN_US: u32 = 1120;
pub const RC_ESC_DJI_MAX_US: u32 = 1920;
pub const __BITS_PER_LONG: u32 = 32;
pub const _IOC_NRBITS: u32 = 8;
pub const _IOC_TYPEBITS: u32 = 8;
pub const _IOC_SIZEBITS: u32 = 14;
pub const _IOC_DIRBITS: u32 = 2;
pub const _IOC_NRMASK: u32 = 255;
pub const _IOC_TYPEMASK: u32 = 255;
pub const _IOC_SIZEMASK: u32 = 16383;
pub const _IOC_DIRMASK: u32 = 3;
pub const _IOC_NRSHIFT: u32 = 0;
pub const _IOC_TYPESHIFT: u32 = 8;
pub const _IOC_SIZESHIFT: u32 = 16;
pub const _IOC_DIRSHIFT: u32 = 30;
pub const _IOC_NONE: u32 = 0;
pub const _IOC_WRITE: u32 = 1;
pub const _IOC_READ: u32 = 2;
pub const IOC_IN: u32 = 1073741824;
pub const IOC_OUT: u32 = 2147483648;
pub const IOC_INOUT: u32 = 3221225472;
pub const IOCSIZE_MASK: u32 = 1073676288;
pub const IOCSIZE_SHIFT: u32 = 16;
pub const SPI_CPHA: u32 = 1;
pub const SPI_CPOL: u32 = 2;
pub const SPI_MODE_0: u32 = 0;
pub const SPI_MODE_1: u32 = 1;
pub const SPI_MODE_2: u32 = 2;
pub const SPI_MODE_3: u32 = 3;
pub const SPI_CS_HIGH: u32 = 4;
pub const SPI_LSB_FIRST: u32 = 8;
pub const SPI_3WIRE: u32 = 16;
pub const SPI_LOOP: u32 = 32;
pub const SPI_NO_CS: u32 = 64;
pub const SPI_READY: u32 = 128;
pub const SPI_TX_DUAL: u32 = 256;
pub const SPI_TX_QUAD: u32 = 512;
pub const SPI_RX_DUAL: u32 = 1024;
pub const SPI_RX_QUAD: u32 = 2048;
pub const SPI_IOC_MAGIC: u8 = 107u8;
pub const RC_SPI_MAX_SPEED: u32 = 24000000;
pub const RC_SPI_MIN_SPEED: u32 = 1000;
pub const RC_SPI_BITS_PER_WORD: u32 = 8;
pub const RC_PID_DIR: &'static [u8; 10usize] = b"/run/shm/\0";
pub const RC_PID_FILE: &'static [u8; 26usize] = b"/run/shm/robotcontrol.pid\0";
pub const _SYS_TIME_H: u32 = 1;
pub const _STRUCT_TIMEVAL: u32 = 1;
pub const _SYS_SELECT_H: u32 = 1;
pub const _SIGSET_H_types: u32 = 1;
pub const FD_SETSIZE: u32 = 1024;
pub const RC_LIB_VERSION_MAJOR: u32 = 1;
pub const RC_LIB_VERSION_MINOR: u32 = 0;
pub const RC_LIB_VERSION_PATCH: u32 = 4;
pub const RC_LIB_VERSION_HEX: u32 = 65540;
extern "C" {
    #[doc = " @brief      initializes the analog to digital converter for reading"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_adc_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Cleans up the ADC subsystem."]
    #[doc = ""]
    #[doc = "             Call before your program closes down"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_adc_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      reads the raw integer ADC value for a particular channel"]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 0-7"]
    #[doc = ""]
    #[doc = " @return     16-bit adc reading on success, -1 on failure."]
    pub fn rc_adc_read_raw(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      reads an adc voltage."]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 0-7"]
    #[doc = ""]
    #[doc = " @return     voltage from 0-1.8v or -1 on error"]
    pub fn rc_adc_read_volt(ch: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief      reads the voltage of the 2-cell Lithium battery"]
    #[doc = ""]
    #[doc = " @return     voltage of battery or -1 on failure"]
    pub fn rc_adc_batt() -> f64;
}
extern "C" {
    #[doc = " @brief      Reads the voltage of the 9-18v DC jack"]
    #[doc = ""]
    #[doc = " @return     Voltage at DC jack or -1 on failure"]
    pub fn rc_adc_dc_jack() -> f64;
}
#[doc = "< update rate 182 HZ"]
pub const rc_bmp_oversample_t_BMP_OVERSAMPLE_1: rc_bmp_oversample_t = 4;
#[doc = "< update rate 133 HZ"]
pub const rc_bmp_oversample_t_BMP_OVERSAMPLE_2: rc_bmp_oversample_t = 8;
#[doc = "< update rate 87 HZ"]
pub const rc_bmp_oversample_t_BMP_OVERSAMPLE_4: rc_bmp_oversample_t = 12;
#[doc = "< update rate 51 HZ"]
pub const rc_bmp_oversample_t_BMP_OVERSAMPLE_8: rc_bmp_oversample_t = 16;
#[doc = "< update rate 28 HZ"]
pub const rc_bmp_oversample_t_BMP_OVERSAMPLE_16: rc_bmp_oversample_t = 20;
#[doc = " Setting given to rc_bmp_init which defines the oversampling"]
#[doc = " done internally to the barometer. For example, if BMP_OVERSAMPLE_16 is used"]
#[doc = " then the barometer will average 16 samples before updating the data"]
#[doc = " registers. The more oversampling used, the slower the data registers will"]
#[doc = " update. You should pick an oversample that provides an update rate slightly"]
#[doc = " slower than the rate at which you will be reading the barometer."]
pub type rc_bmp_oversample_t = u32;
pub const rc_bmp_filter_t_BMP_FILTER_OFF: rc_bmp_filter_t = 0;
pub const rc_bmp_filter_t_BMP_FILTER_2: rc_bmp_filter_t = 4;
pub const rc_bmp_filter_t_BMP_FILTER_4: rc_bmp_filter_t = 8;
pub const rc_bmp_filter_t_BMP_FILTER_8: rc_bmp_filter_t = 12;
pub const rc_bmp_filter_t_BMP_FILTER_16: rc_bmp_filter_t = 16;
#[doc = " Setting given to rc_bmp_init to configure the coefficient of the internal"]
#[doc = " first order filter. We recommend disabling the filter with BMP_FILTER_OFF and"]
#[doc = " doing your own filtering with the discrete filter functions below."]
pub type rc_bmp_filter_t = u32;
#[doc = " struct to hold the data retreived during one read of the barometer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_bmp_data_t {
    #[doc = "< temperature in degrees celcius"]
    pub temp_c: f64,
    #[doc = "< altitude in meters"]
    pub alt_m: f64,
    #[doc = "< current pressure in pascals"]
    pub pressure_pa: f64,
}
#[test]
fn bindgen_test_layout_rc_bmp_data_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_bmp_data_t>(),
        24usize,
        concat!("Size of: ", stringify!(rc_bmp_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_bmp_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rc_bmp_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_bmp_data_t>())).temp_c as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_bmp_data_t),
            "::",
            stringify!(temp_c)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_bmp_data_t>())).alt_m as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_bmp_data_t),
            "::",
            stringify!(alt_m)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_bmp_data_t>())).pressure_pa as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_bmp_data_t),
            "::",
            stringify!(pressure_pa)
        )
    );
}
extern "C" {
    #[doc = " @brief      powers on the barometer and initializes it with the given"]
    #[doc = " oversample and filter settings."]
    #[doc = ""]
    #[doc = " Optionally call rc_bmp_set_sea_level_pressure_pa afterwards to change the sea"]
    #[doc = " level pressure from default."]
    #[doc = ""]
    #[doc = " @param[in]  oversample  see rc_bmp_oversample_t"]
    #[doc = " @param[in]  filter      see rc_bmp_filter_t"]
    #[doc = ""]
    #[doc = " @return     0 on success, otherwise -1."]
    pub fn rc_bmp_init(
        oversample: rc_bmp_oversample_t,
        filter: rc_bmp_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      If you know the current sea level pressure for your region and"]
    #[doc = " weather, you can use this to correct the altititude reading."]
    #[doc = ""]
    #[doc = " This is not necessary if you only care about differential altitude from a"]
    #[doc = " starting point. Must be called after rc_bmp_init to have an effect."]
    #[doc = ""]
    #[doc = " @param[in]  pa    sea level pressure in pascals"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_bmp_set_sea_level_pressure_pa(pa: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Puts the barometer into a low power state, should be called at"]
    #[doc = " the end of your program before close."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_bmp_power_off() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads the newest temperature and pressure measurments from the"]
    #[doc = " barometer over the I2C bus."]
    #[doc = ""]
    #[doc = " @param      data  pointer to data struct where new data will be written."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_bmp_read(data: *mut rc_bmp_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes a single button handler."]
    #[doc = ""]
    #[doc = " @param[in]  chip         The gpio chip"]
    #[doc = " @param[in]  pin          The gpio pin for that chip"]
    #[doc = " @param[in]  polarity     RC_BTN_POLARITY_NORM_HIGH if using with a pullup"]
    #[doc = " resistor, use this for the BeagleBone Blue and Robotics Cape MODE and PAUSE"]
    #[doc = " buttons. Alternatively use RC_BTN_POLARITY_NORM_LOW if you are using your own"]
    #[doc = " button on another pin set up with a pulldown resistor."]
    #[doc = " @param[in]  debounce_us  debounce interval in microseconds. Set to 0 for no"]
    #[doc = " debounce. Usually should set to RC_BTN_DEBOUNCE_DEFAULT_US."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_button_init(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        polarity: ::std::os::raw::c_char,
        debounce_us: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Closes all button handlers. Call at the end of your program"]
    #[doc = " before returning."]
    pub fn rc_button_cleanup();
}
extern "C" {
    #[doc = " @brief      Sets the callback functions to be called when the button is"]
    #[doc = " pressed or released."]
    #[doc = ""]
    #[doc = " These functions should be short and return quickly. On every press and"]
    #[doc = " release a new thread is created to run your callback functions. If your"]
    #[doc = " callbacks take too long to return then multiple instances of them will run in"]
    #[doc = " parallel which may or may not be desirable."]
    #[doc = ""]
    #[doc = " @param[in]  chip          The gpio chip"]
    #[doc = " @param[in]  pin           The gpio pin for that chip"]
    #[doc = " @param[in]  press_func    callback when button is pressed, set to NULL if no"]
    #[doc = " callback is desired."]
    #[doc = " @param[in]  release_func  callback when button is released, set to NULL if no"]
    #[doc = " callback is desired."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_button_set_callbacks(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        press_func: ::std::option::Option<unsafe extern "C" fn()>,
        release_func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      used to query the position of a button."]
    #[doc = ""]
    #[doc = " @param[in]  chip  The gpio chip"]
    #[doc = " @param[in]  pin   The gpio pin for that chip"]
    #[doc = ""]
    #[doc = " @return     RC_BTN_STATE_PRESSED or RC_BTN_STATE_RELEASED on success, -1 on"]
    #[doc = " failure."]
    pub fn rc_button_get_state(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      blocking function call, returns when press or release happens"]
    #[doc = ""]
    #[doc = " @param[in]  chip              The gpio chip"]
    #[doc = " @param[in]  pin               The gpio pin for that chip"]
    #[doc = " @param[in]  press_or_release  RC_BTN_STATE_PRESSED or RC_BTN_STATE_RELEASED"]
    #[doc = ""]
    #[doc = " @return     0 on successful event, -1 on error"]
    pub fn rc_button_wait_for_event(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        press_or_release: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
#[doc = "< Sets CPU to slowest speed"]
pub const rc_governor_t_RC_GOV_POWERSAVE: rc_governor_t = 0;
#[doc = "< Sets CPU to fastest speed"]
pub const rc_governor_t_RC_GOV_PERFORMANCE: rc_governor_t = 1;
#[doc = "< Default automatic scaling"]
pub const rc_governor_t_RC_GOV_ONDEMAND: rc_governor_t = 2;
#[doc = "< Like ONDEMAND but newer algorithm"]
pub const rc_governor_t_RC_GOV_SCHEDUTIL: rc_governor_t = 3;
#[doc = "< Automatically scales the cpu but still tries to save power"]
pub const rc_governor_t_RC_GOV_CONSERVATIVE: rc_governor_t = 4;
#[doc = " available CPU governors"]
pub type rc_governor_t = u32;
extern "C" {
    #[doc = " @brief      Sets the CPU governor. See rc_governor_t"]
    #[doc = ""]
    #[doc = " This is the equivalent to running 'cpufreq-set -g {governor}' from the"]
    #[doc = " command line but can be called in your C program instead."]
    #[doc = ""]
    #[doc = " @param[in]  gov   Desired governor"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_cpu_set_governor(gov: rc_governor_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the current clock speed of the Beaglebone's Sitara"]
    #[doc = " processor in the form of the provided enumerated type. It will never return"]
    #[doc = " the FREQ_ONDEMAND value as the intention of this function is to see the clock"]
    #[doc = " speed as set by either the user or the ondemand governor itself."]
    #[doc = ""]
    #[doc = " @return     frequency in hz"]
    pub fn rc_cpu_get_freq() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints the current frequency to the screen. For example \"600mhz\"."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_cpu_print_freq() -> ::std::os::raw::c_int;
}
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
extern "C" {
    #[doc = " @brief      Starts the DSM background service"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_dsm_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      stops the DSM background service"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure. 1 if there was a timeout due to user"]
    #[doc = " callback function not returning."]
    pub fn rc_dsm_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the pulse width in microseconds commanded by the"]
    #[doc = " transmitter for a particular channel."]
    #[doc = ""]
    #[doc = " The user can specify channels 1 through 9 but non-zero values will only be"]
    #[doc = " returned for channels the transmitter is actually using. The raw values in"]
    #[doc = " microseconds typically range from 900-2100us for a standard radio with"]
    #[doc = " default settings."]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel (1-9)"]
    #[doc = ""]
    #[doc = " @return     pulse width in microseconds if data is being transmitted, 0 if"]
    #[doc = " data is not being transmitted on that channel, -1 on error"]
    pub fn rc_dsm_ch_raw(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns a scaled value from -1 to 1 corresponding to the min and"]
    #[doc = " max values recorded during calibration."]
    #[doc = ""]
    #[doc = " The user MUST run the rc_calibrate_dsm example to ensure the normalized"]
    #[doc = " values returned by this function are correct. It is possible that values"]
    #[doc = " outside of the range from -1 to 1 are returned if the calibration is not"]
    #[doc = " perfect."]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel (1-9)"]
    #[doc = ""]
    #[doc = " @return     normalized input from -1.0 to 1.0 if that channel has data, 0 if"]
    #[doc = " that channel has no data, -1 on error."]
    pub fn rc_dsm_ch_normalized(ch: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief      This is a check to see if new data is available."]
    #[doc = ""]
    #[doc = " After new data is received this will return 1. It will return 0 as soon as"]
    #[doc = " any channel has been read by either rc_dsm_ch_raw or rc_dsm_ch_normalized."]
    #[doc = ""]
    #[doc = " @return     returns 1 if new data is ready to be read by the user. otherwise"]
    #[doc = " returns 0"]
    pub fn rc_dsm_is_new_data() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Set your own callback function to be called when new DSM data is"]
    #[doc = " ready."]
    #[doc = ""]
    #[doc = " @param[in]  func  callback function"]
    pub fn rc_dsm_set_callback(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " @brief      Set your own callback function to be called when DSM loses"]
    #[doc = " connection."]
    #[doc = ""]
    #[doc = " @param[in]  func  callback function"]
    pub fn rc_dsm_set_disconnect_callback(func: ::std::option::Option<unsafe extern "C" fn()>);
}
extern "C" {
    #[doc = " @brief      Easily check on the state of the DSM radio packets without"]
    #[doc = " checking timeouts yourself."]
    #[doc = ""]
    #[doc = " @return     returns 1 if packets are arriving in good health without"]
    #[doc = " timeouts. returns 0 otherwise."]
    pub fn rc_dsm_is_connection_active() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Measures time since the last DSM packet was received."]
    #[doc = ""]
    #[doc = " @return     Returns the number of nanoseconds since the last dsm packet was"]
    #[doc = " received. Return -1 on error or if no packet has ever been received."]
    pub fn rc_dsm_nanos_since_last_packet() -> i64;
}
extern "C" {
    #[doc = " @brief      Used to determine if DSM packets are arriving with 10 or 11-bit"]
    #[doc = " resolution"]
    #[doc = ""]
    #[doc = " @return     returns 10 or 11 indicating 10-bit or 11-bit resolution returns a"]
    #[doc = " 0 if no packet has been received yet or -1 on error"]
    pub fn rc_dsm_resolution() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      fetches number of DSM channels currently being received."]
    #[doc = ""]
    #[doc = " @return     Returns number of channels being received, 0 if no packet has"]
    #[doc = " been received yet or -1 on error."]
    pub fn rc_dsm_channels() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Begins the binding routine and prints instructions to the screen"]
    #[doc = " along the way."]
    #[doc = ""]
    #[doc = " The user doesn't need to call this function unless they really want to. Use"]
    #[doc = " the rc_bind_dsm example program instead."]
    #[doc = ""]
    #[doc = " DSM satellite receivers are put into bind mode by sending them a sequence of"]
    #[doc = " pulses right after it receives power and starts up. This program puts the"]
    #[doc = " normally UART signal pin into GPIO pulldown mode temporarily, detects when"]
    #[doc = " the user unplugs and plugs back in the receiver, then sends the binding"]
    #[doc = " pulses."]
    #[doc = ""]
    #[doc = " The number of pulses dictates the mode the satellite receiver will request"]
    #[doc = " the transmitter to use. The transmitter may bind but use a different mode. I"]
    #[doc = " suggest configuring your radio to use DSMX 11ms fast mode if it allows that."]
    #[doc = ""]
    #[doc = " 2048 & 1024 indicates 10 or 11 bit resolution. 11ms & 22ms indicates the time"]
    #[doc = " period between the transmitter sending frames. 11ms is required for"]
    #[doc = " transmitters with 8 or more channels."]
    #[doc = ""]
    #[doc = " Testing done with DX7s, DX6i, DX8, and Orange T-SIX"]
    #[doc = ""]
    #[doc = " Table of Bind Modes"]
    #[doc = ""]
    #[doc = " | pulses |      mode       |"]
    #[doc = " |:------:|:---------------:|"]
    #[doc = " |   3    |  DSM  1024/22ms |"]
    #[doc = " |   5    |  DSM  2048/11ms |"]
    #[doc = " |   7    |  DSMX 1024/22ms |"]
    #[doc = " |   9    |  DSMX 2048/11ms |"]
    #[doc = ""]
    #[doc = " This is a bit of a finicky process and may require a few attempts to work."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_dsm_bind_routine() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      routine for measuring the min and max values from a transmitter"]
    #[doc = " on each channel and save to disk for future use."]
    #[doc = ""]
    #[doc = " If a channel isn't used by the transmitter then default values are saved. if"]
    #[doc = " the user forgot to move one of the channels during the calibration process"]
    #[doc = " then defualt values are also saved."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_dsm_calibrate_routine() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes the eQEP encoder counters for channels 1-3"]
    #[doc = ""]
    #[doc = " This also resets the encoder position to 0 so the first position read is"]
    #[doc = " consistent. Note this does NOT initialize the PRU-accelerated encoder counter"]
    #[doc = " on channel 4. To use the 4th channel you must use <rc/encoder_pru.h>"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_encoder_eqep_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Stops the eQEP encoder counters and closes file descriptors. This"]
    #[doc = " is not strictly necessary but is recommended that the user calls this"]
    #[doc = " function at the end of their program."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_encoder_eqep_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads the current position of an encoder channel."]
    #[doc = ""]
    #[doc = " This is a signed 32-bit integer that wraps around if the position is allowed"]
    #[doc = " to read +- 2^31"]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 1-3"]
    #[doc = ""]
    #[doc = " @return     The current position (signed 32-bit integer) or -1 and prints an"]
    #[doc = " error message is there is a problem."]
    pub fn rc_encoder_eqep_read(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the current position of an eQEP encoder channel. Usually for"]
    #[doc = " resetting a counter to 0 but can set an arbitrary position if desired."]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 1-3"]
    #[doc = " @param[in]  pos   The new position"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_encoder_eqep_write(
        ch: ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes the pru encoder counter for channel 4"]
    #[doc = ""]
    #[doc = " This also resets the encoder position to 0 so the first position read is"]
    #[doc = " consistent. Note this does NOT initialize the eqep-accelerated encoder"]
    #[doc = " counters on channels 1-3. To use channels 1-3 you must use"]
    #[doc = " <rc/encoder_eqep.h>"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_encoder_pru_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Stops the PRU encoder counter and closes file descriptors. This"]
    #[doc = " is not strictly necessary but is recommended that the user calls this"]
    #[doc = " function at the end of their program."]
    pub fn rc_encoder_pru_cleanup();
}
extern "C" {
    #[doc = " @brief      Reads the current position of encoder channel 4."]
    #[doc = ""]
    #[doc = " This is a signed 32-bit integer that wraps around if the position is allowed"]
    #[doc = " to read +- 2^31"]
    #[doc = ""]
    #[doc = " @return     The current position (signed 32-bit integer) or -1 and prints an"]
    #[doc = " error message is there is a problem."]
    pub fn rc_encoder_pru_read() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the current position of encoder channel 4. Usually for"]
    #[doc = " resetting a counter to 0 but can set an arbitrary position if desired."]
    #[doc = ""]
    #[doc = " @param[in]  pos   The new position"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_encoder_pru_write(pos: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes counters for channels 1-4"]
    #[doc = ""]
    #[doc = " This also resets the encoder position to 0 so the first position read is"]
    #[doc = " consistent."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_encoder_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Stops the encoder counters and closes file descriptors. This is"]
    #[doc = " not strictly necessary but is recommended that the user calls this function"]
    #[doc = " at the end of their program."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_encoder_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads the current position of an encoder channel."]
    #[doc = ""]
    #[doc = " This is a signed 32-bit integer that wraps around if the position is allowed"]
    #[doc = " to read +- 2^31"]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 1-4"]
    #[doc = ""]
    #[doc = " @return     The current position (signed 32-bit integer) or -1 and prints an"]
    #[doc = " error message is there is a problem."]
    pub fn rc_encoder_read(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the current position of an eQEP encoder channel. Usually for"]
    #[doc = " resetting a counter to 0 but can set an arbitrary position if desired."]
    #[doc = ""]
    #[doc = " @param[in]  ch    channel 1-4"]
    #[doc = " @param[in]  pos   The new position"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_encoder_write(
        ch: ::std::os::raw::c_int,
        pos: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Configures a gpio pin as input or output"]
    #[doc = ""]
    #[doc = " This configures the pin by making a gpio handle request to the character"]
    #[doc = " device driver. It accepts the same gpio handle request flags as defined in"]
    #[doc = " <linux/gpio.h>"]
    #[doc = ""]
    #[doc = " - GPIOHANDLE_REQUEST_INPUT"]
    #[doc = " - GPIOHANDLE_REQUEST_OUTPUT"]
    #[doc = " - GPIOHANDLE_REQUEST_ACTIVE_LOW"]
    #[doc = " - GPIOHANDLE_REQUEST_OPEN_DRAIN"]
    #[doc = " - GPIOHANDLE_REQUEST_OPEN_SOURCE"]
    #[doc = ""]
    #[doc = " Obviously the INPUT and OUTPUT flags cannot be used at the same time. If you"]
    #[doc = " don't know what the other flags mean just stick with INPUT and OUTPUT modes,"]
    #[doc = " that covers 99% of use cases."]
    #[doc = ""]
    #[doc = " @param[in]  chip          The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin           The pin ID"]
    #[doc = " @param[in]  handle_flags  The handle flags"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_gpio_init(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        handle_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the value of a GPIO pin when in output mode"]
    #[doc = ""]
    #[doc = " must call rc_gpio_init with the OUTPUT flag first."]
    #[doc = ""]
    #[doc = " @param[in]  chip   The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin    The pin ID"]
    #[doc = " @param[in]  value  0 for off (inactive), nonzero for on (active)"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_gpio_set_value(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads the value of a GPIO pin when in input mode or output mode."]
    #[doc = ""]
    #[doc = " Must call rc_gpio_init first."]
    #[doc = ""]
    #[doc = " @param[in]  chip  The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin   The pin ID"]
    #[doc = ""]
    #[doc = " @return     1 if pin is high, 0 if pin is low, -1 on error"]
    pub fn rc_gpio_get_value(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes a pin for interrupt event polling and normal reading."]
    #[doc = ""]
    #[doc = " Handle flags exists if the user wishes to configure the pic as active-low,"]
    #[doc = " open-source, or open-drain. This is usually not necessary and can be left at"]
    #[doc = " 0. This function returns the file descriptor used for polling in case the"]
    #[doc = " user wants to use a polling method other than rc_gpio_poll."]
    #[doc = ""]
    #[doc = " @param[in]  chip          The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin           The pin ID"]
    #[doc = " @param[in]  handle_flags  Additional pin configuration flags, this can"]
    #[doc = " usually be left as 0"]
    #[doc = " @param[in]  event_flags   The event flags, GPIOEVENT_REQUEST_RISING_EDGE,"]
    #[doc = " GPIOEVENT_REQUEST_FALLING_EDGE, or GPIOEVENT_REQUEST_BOTH_EDGES"]
    #[doc = ""]
    #[doc = " @return     File descriptor for the GPIO event or -1 on failure"]
    pub fn rc_gpio_init_event(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        handle_flags: ::std::os::raw::c_int,
        event_flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      polls a pin when configured for interrupt event polling"]
    #[doc = ""]
    #[doc = " This polls for an event and then reads one event from the queue."]
    #[doc = ""]
    #[doc = " @param[in]  chip           The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin            The pin ID"]
    #[doc = " @param[in]  timeout_ms     The timeout in milliseconds. Negative value causes"]
    #[doc = " infinite timeout, a value of 0 makes the function return immediately after"]
    #[doc = " reading an event in the queue."]
    #[doc = " @param[out] event_time_ns  pointer where the time of the gpio event occured."]
    #[doc = " Units are nanoseconds since epoch. Set this as NULL if you don't want to keep"]
    #[doc = " the time."]
    #[doc = ""]
    #[doc = " @return     returns RC_GPIO_EVENT_ERROR, RC_GPIO_EVENT_TIMEOUT,"]
    #[doc = " RC_GPIO_EVENT_RISING_EDGE, or RC_GPIO_EVENT_FALLING_EDGE to indicate what"]
    #[doc = " happened."]
    pub fn rc_gpio_poll(
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
        timeout_ms: ::std::os::raw::c_int,
        event_time_ns: *mut u64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      closes the file descriptor for a pin"]
    #[doc = ""]
    #[doc = " Not strictly necessary to run at the end of your program since linux will"]
    #[doc = " clean this up for you. However this is sometimes useful in the middle of a"]
    #[doc = " program when a pin is no longer needed."]
    #[doc = ""]
    #[doc = " @param[in]  chip  The chip number, /dev/gpiochipX"]
    #[doc = " @param[in]  pin   The pin ID"]
    pub fn rc_gpio_cleanup(chip: ::std::os::raw::c_int, pin: ::std::os::raw::c_int);
}
pub type wchar_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __clang_max_align_nonce2: f64,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        16usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        8usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce1 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<max_align_t>())).__clang_max_align_nonce2 as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
extern "C" {
    #[doc = " @brief      Initializes a bus and sets it to talk to a particular device"]
    #[doc = "             address."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  devAddr  The device address"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_init(bus: ::std::os::raw::c_int, devAddr: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Closes an I2C bus"]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_close(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Changes the device address the bus is configured to talk to."]
    #[doc = ""]
    #[doc = "             Actually changing the device address in the I2C driver requires a"]
    #[doc = "             system call and is relatively slow. This function records which"]
    #[doc = "             device address the bus is set to and will only make the system"]
    #[doc = "             call if the requested address is different than the set address."]
    #[doc = "             This makes it safe to call this function repeatedly with no"]
    #[doc = "             performance penalty."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  devAddr  The new device address"]
    #[doc = ""]
    #[doc = " @return     { description_of_the_return_value }"]
    pub fn rc_i2c_set_device_address(
        bus: ::std::os::raw::c_int,
        devAddr: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads a single byte from a device register."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address to be read"]
    #[doc = "             from before reading the response, works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[out] data     The data pointer to write response to."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_read_byte(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads multiple bytes from a device register."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address to be read"]
    #[doc = "             from before reading the response, works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[in]  count   number of bytes to read"]
    #[doc = " @param[out] data     The data pointer to write response to."]
    #[doc = ""]
    #[doc = " @return     returns number of bytes read or -1 on failure"]
    pub fn rc_i2c_read_bytes(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        count: usize,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads a single word (16 bits) from a device register."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address to be read"]
    #[doc = "             from before reading the response, works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[out] data     The data pointer to write response to."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_read_word(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        data: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads multiple words (16 bytes each) from a device register."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address to be read"]
    #[doc = "             from before reading the response, works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[in]  count    Number of 16-bit words to read, NOT number of bytes to read"]
    #[doc = " @param[out] data     The data pointer to write response to."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_read_words(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        count: usize,
        data: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Writes a single byte to a specified register address."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address followed by"]
    #[doc = "             the actual data to be written. Works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[in]  data     Single byte to be writen"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_write_byte(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        data: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Writes multiple bytes to a specified register address."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address followed by"]
    #[doc = "             the actual data to be written. Works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address to write to"]
    #[doc = " @param[in]  count    The number of bytes to write"]
    #[doc = " @param      data     pointer to user's data to be writen"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_write_bytes(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        count: usize,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Writes a single word (16 bits) to a specified register address."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address followed by"]
    #[doc = "             the actual data to be written. Works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address to write to"]
    #[doc = " @param[in]  data     16-bit word to be written"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_write_word(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        data: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Writes multiple words (16 bits each) to a specified register"]
    #[doc = "             address."]
    #[doc = ""]
    #[doc = "             This sends the device address and register address followed by"]
    #[doc = "             the actual data to be written. Works for most i2c devices."]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = " @param[in]  regAddr  The register address"]
    #[doc = " @param[in]  count    Number of 16-bit words to write, NOT number of bytes"]
    #[doc = " @param[in]  data     The data"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_write_words(
        bus: ::std::os::raw::c_int,
        regAddr: u8,
        count: usize,
        data: *mut u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sends exactly user-defined data without prepending a register"]
    #[doc = "             address."]
    #[doc = ""]
    #[doc = "             Instead of automatically sending a device address before the data"]
    #[doc = "             which is typical for reading/writing registers, the"]
    #[doc = "             rc_i2c_send_bytes function send only the data given by the data"]
    #[doc = "             argument. This is useful for more complicated IO such as"]
    #[doc = "             uploading firmware to a device."]
    #[doc = ""]
    #[doc = " @param[in]  bus     The bus"]
    #[doc = " @param[in]  count   Number of bytes to send"]
    #[doc = " @param[in]  data    The data"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_send_bytes(
        bus: ::std::os::raw::c_int,
        count: usize,
        data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sends exactly user-defined data without prepending a register"]
    #[doc = "             address."]
    #[doc = ""]
    #[doc = "             Instead of automatically sending a device address before the data"]
    #[doc = "             which is typical for reading/writing registers, the"]
    #[doc = "             rc_i2c_send_bytes function send only the data given by the data"]
    #[doc = "             argument. This is useful for more complicated IO such as"]
    #[doc = "             uploading firmware to a device."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus"]
    #[doc = " @param[in]  data  The data"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_i2c_send_byte(bus: ::std::os::raw::c_int, data: u8) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Locks the bus so other threads in the process know the bus is in"]
    #[doc = "             use."]
    #[doc = ""]
    #[doc = "             Locking a bus is similar to locking a mutex, it is a way for"]
    #[doc = "             threads to communicate within one process when sharing a bus."]
    #[doc = "             This, however, is not a hard lock in the sense that it does not"]
    #[doc = "             block and does not stop any of the other functions in this API"]
    #[doc = "             from being called. It only serves as a flag that can be checked"]
    #[doc = "             between threads if the user chooses to do so. This is encouraged"]
    #[doc = "             in multithraded applications to prevent timing-sensitive i2c"]
    #[doc = "             communication from being interrupted but is not enforced."]
    #[doc = ""]
    #[doc = "             All read/write functions in this API will lock the bus during the"]
    #[doc = "             transaction and return the lockstate to what it was at the"]
    #[doc = "             beginning of the transaction. Ideally the user should lock the"]
    #[doc = "             bus themselves before a sequence of transactions and unlock it"]
    #[doc = "             afterwards."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus ID"]
    #[doc = ""]
    #[doc = " @return     Returns the lock state (0 or 1) when this function is called, or -1 on"]
    #[doc = "             error."]
    pub fn rc_i2c_lock_bus(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Unlocks a bus to indicate to other threads in the process that"]
    #[doc = "             the bus is now free."]
    #[doc = ""]
    #[doc = "             see rc_i2c_lock_bus for further description."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus ID"]
    #[doc = ""]
    #[doc = " @return     Returns the lock state (0 or 1) when this function is called, or -1 on"]
    #[doc = "             error."]
    pub fn rc_i2c_unlock_bus(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fetches the current lock state of the bus."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus ID"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if unlocked, 1 if locked, or -1 on error."]
    pub fn rc_i2c_get_lock(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Gets file descriptor."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]  bus      The bus"]
    #[doc = ""]
    #[doc = " @return     returns file descriptor of the specified bus or -1 on failure"]
    pub fn rc_i2c_get_fd(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub const rc_led_t_RC_LED_GREEN: rc_led_t = 0;
pub const rc_led_t_RC_LED_RED: rc_led_t = 1;
pub const rc_led_t_RC_LED_USR0: rc_led_t = 2;
pub const rc_led_t_RC_LED_USR1: rc_led_t = 3;
pub const rc_led_t_RC_LED_USR2: rc_led_t = 4;
pub const rc_led_t_RC_LED_USR3: rc_led_t = 5;
pub const rc_led_t_RC_LED_BAT25: rc_led_t = 6;
pub const rc_led_t_RC_LED_BAT50: rc_led_t = 7;
pub const rc_led_t_RC_LED_BAT75: rc_led_t = 8;
pub const rc_led_t_RC_LED_BAT100: rc_led_t = 9;
pub const rc_led_t_RC_LED_WIFI: rc_led_t = 10;
#[doc = " @brief      Availabe LEDs on the BeagleBone platform."]
#[doc = ""]
#[doc = " This list may expand for future boards. Note that the WIFI and USR LEDs are"]
#[doc = " normally controlled by separate processes. They can be controlled, but may"]
#[doc = " conflict as other processes continue to try to write to them simultaneously."]
#[doc = ""]
#[doc = " The BAT LED's are controlled by the rc_battery_monitor service. If you want"]
#[doc = " to control these LEDs yourself please stop the service first."]
#[doc = ""]
#[doc = " ```bash"]
#[doc = " sudo systemctl stop rc_battery_monitor"]
#[doc = " sudo systemctl disable rc_battery_monitor"]
#[doc = " ```"]
pub type rc_led_t = u32;
extern "C" {
    #[doc = " @brief      sets the state of an LED"]
    #[doc = ""]
    #[doc = " @param[in]  led    rc_led_t enum"]
    #[doc = " @param[in]  value  0 for OFF, non-zero for ON"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_led_set(led: rc_led_t, value: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      closes file descriptors to all opened LEDs"]
    #[doc = ""]
    #[doc = " This does NOT turn off the LEDs, it is up to the user to leave the LEDs in"]
    #[doc = " the desired state before closing."]
    pub fn rc_led_cleanup();
}
extern "C" {
    #[doc = " @brief      gets the current state of an LED"]
    #[doc = ""]
    #[doc = " @param[in]  led   rc_led_t enum"]
    #[doc = ""]
    #[doc = " @return     0 if off, 1 if on, -1 on error"]
    pub fn rc_led_get(led: rc_led_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      blinks an led at specified frequency and duration."]
    #[doc = ""]
    #[doc = " This is a blocking function call, it does not return until either the"]
    #[doc = " specified duration has completed or rc_led_stop_blink has been called from"]
    #[doc = " another thread."]
    #[doc = ""]
    #[doc = " @param[in]  led       rc_led_t enum"]
    #[doc = " @param[in]  hz        blink frequency in HZ"]
    #[doc = " @param[in]  duration  blink duration in seconds"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on error, 1 if function exited prematurely."]
    pub fn rc_led_blink(led: rc_led_t, hz: f32, duration: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Stops an LED from blinking."]
    #[doc = ""]
    #[doc = " Since rc_led_blink is a blocking function, it's obviously necessary to call"]
    #[doc = " rc_led_stop_blink from a separate thread or signal handler. This will cause"]
    #[doc = " rc_led_blink to return 1 if blinking was stopped mid-way. Also see"]
    #[doc = " rc_led_stop_blink_all"]
    #[doc = ""]
    #[doc = " @param[in]  led   rc_led_t enum"]
    pub fn rc_led_stop_blink(led: rc_led_t);
}
extern "C" {
    #[doc = " @brief      stops all LEDs from blinking"]
    #[doc = ""]
    #[doc = " Since rc_led_blink is a blocking function, it's obviously necessary to call"]
    #[doc = " rc_led_stop_blink from a separate thread or signal handler. This will cause"]
    #[doc = " rc_led_blink to return 1 if blinking was stopped mid-way."]
    pub fn rc_led_stop_blink_all();
}
extern "C" {
    pub static mut zero_tolerance: f64;
}
#[doc = " @brief      Struct containing the state of a vector and a pointer to"]
#[doc = " dynamically allocated memory to hold its contents."]
#[doc = ""]
#[doc = " Set and read values directly with this code:"]
#[doc = " @code{.c}"]
#[doc = " vec.d[position]=new_value; // set value in the vector"]
#[doc = " value = v.d[pos]; // get value from vector"]
#[doc = " @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_vector_t {
    #[doc = "< number of elements in the vector"]
    pub len: ::std::os::raw::c_int,
    #[doc = "< pointer to dynamically allocated data"]
    pub d: *mut f64,
    #[doc = "< initialization flag"]
    pub initialized: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rc_vector_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_vector_t>(),
        12usize,
        concat!("Size of: ", stringify!(rc_vector_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_vector_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rc_vector_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_vector_t>())).len as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_vector_t),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_vector_t>())).d as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_vector_t),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_vector_t>())).initialized as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_vector_t),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief      Returns an rc_vector_t with no allocated memory and the"]
    #[doc = " initialized flag set to 0."]
    #[doc = ""]
    #[doc = " This is essential for initializing vectors when they are declared since"]
    #[doc = " local variables declared in a function without global variable scope in C are"]
    #[doc = " not guaranteed to be zeroed out which can lead to bad memory pointers and"]
    #[doc = " segfaults if not handled carefully. We recommend initializing all vectors"]
    #[doc = " with this function before using rc_vector_alloc or any other function."]
    #[doc = ""]
    #[doc = " @return     rc_vector_t with no allocated memory and the initialized flag set"]
    #[doc = " to 0."]
    pub fn rc_vector_empty() -> rc_vector_t;
}
extern "C" {
    #[doc = " @brief      Allocates memory for vector v to have specified length."]
    #[doc = ""]
    #[doc = " If v is initially the right length then nothing is done and the data in v is"]
    #[doc = " preserved. If v is uninitialized or of the wrong length then any existing"]
    #[doc = " memory is freed and new memory is allocated, helping to prevent accidental"]
    #[doc = " memory leaks."]
    #[doc = ""]
    #[doc = " The contents of the new vector is not guaranteed to be anything in particular"]
    #[doc = " as it is allocated with malloc. Use rc_vector_zeros or rc_vector_ones if you"]
    #[doc = " require known starting values."]
    #[doc = ""]
    #[doc = " Returns 0 if successful, otherwise returns -1. Will only be unsuccessful if"]
    #[doc = " length is invalid or there is insufficient memory available."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_alloc(
        v: *mut rc_vector_t,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Frees the memory allocated for vector v."]
    #[doc = ""]
    #[doc = " Also sets the length and initialized flag of the rc_vector_t struct to 0 to"]
    #[doc = " indicate to other functions that v no longer points to allocated memory and"]
    #[doc = " cannot be used until more memory is allocated such as with rc_vector_alloc or"]
    #[doc = " rc_vector_zeros. Returns 0 on success. Will only fail and return -1 if it is"]
    #[doc = " passed a NULL pointer."]
    #[doc = ""]
    #[doc = " @param      v     Pointer to user's rc_vector_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_free(v: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes vector v and fills with zeros."]
    #[doc = ""]
    #[doc = " uses calloc to allocate new memory. Any existing memory allocated for v is"]
    #[doc = " freed if necessary to avoid memory leaks. It is not necessary to call"]
    #[doc = " rc_alloc_vector before this."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_zeros(
        v: *mut rc_vector_t,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes vector v and fills with ones."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for v is freed if necessary to avoid memory"]
    #[doc = " leaks. It is not necessary to call rc_alloc_vector before this."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_ones(
        v: *mut rc_vector_t,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes vector v and fills with random numbers between -1.0 and"]
    #[doc = " 1.0"]
    #[doc = ""]
    #[doc = " Any existing memory allocated for v is freed if necessary to avoid memory"]
    #[doc = " leaks. It is not necessary to call rc_alloc_vector before this."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_random(
        v: *mut rc_vector_t,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes vector v and fills with Fibonnaci sequence"]
    #[doc = ""]
    #[doc = " Any existing memory allocated for v is freed if necessary to avoid memory"]
    #[doc = " leaks. It is not necessary to call rc_alloc_vector before this."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_fibonnaci(
        v: *mut rc_vector_t,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes vector v and populates with values from specified array"]
    #[doc = " ptr."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for v is freed if necessary to avoid memory"]
    #[doc = " leaks. It is not necessary to call rc_alloc_vector before this. This is"]
    #[doc = " generally used when the user has an existing array of data and wants to use"]
    #[doc = " it with other math functions."]
    #[doc = ""]
    #[doc = " @param      v       Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  ptr     pointer to array to read values from"]
    #[doc = " @param[in]  length  Length of vector to allocate memory for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_from_array(
        v: *mut rc_vector_t,
        ptr: *mut f64,
        length: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Duplicates the contents of vector a and into a new vector b."]
    #[doc = ""]
    #[doc = " Simply making a copy of an rc_vector_t struct is not sufficient as the"]
    #[doc = " rc_vector_t struct simply contains a pointer to the memory allocated to"]
    #[doc = " contain the contents of the vector. rc_vector_duplicate sets b to be a new"]
    #[doc = " rc_vector_t with a pointer to freshly-allocated memory."]
    #[doc = ""]
    #[doc = " @param[in]  a     Vector to be duplicated"]
    #[doc = " @param      b     pointer to new vector to be allocated and written"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful, otherwise returns -1."]
    pub fn rc_vector_duplicate(a: rc_vector_t, b: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints to stdout the contents of vector v in one line."]
    #[doc = ""]
    #[doc = " This is not advisable for extremely long vectors but serves for quickly"]
    #[doc = " debugging or printing results. It prints 4 decimal places with padding for a"]
    #[doc = " sign. We recommend rc_vector_print_sci() for very small or very large numbers"]
    #[doc = " where scientific notation would be more appropriate."]
    #[doc = ""]
    #[doc = " @param[in]  v     Pointer to user's rc_vector_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_vector_print(v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints to stdout the contents of vector v in one line."]
    #[doc = ""]
    #[doc = " Like rc_vector_print but prints with scientific notation. This is not"]
    #[doc = " advisable for extremely long vectors but serves for quickly debugging or"]
    #[doc = " printing."]
    #[doc = ""]
    #[doc = " @param[in]  v     Pointer to user's rc_vector_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_vector_print_sci(v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets all values of an already-allocated vector to 0"]
    #[doc = ""]
    #[doc = " @param      v     pointer to vector to be zero'd out"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_vector_zero_out(v: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies every entry in vector v by scalar s."]
    #[doc = ""]
    #[doc = " It is not strictly necessary for v to be provided as a pointer since a copy"]
    #[doc = " of the struct v would also contain the correct pointer to the original"]
    #[doc = " vector's allocated memory. However, in this library we use the convention of"]
    #[doc = " passing an rc_vector_t struct or rc_matrix_struct as a pointer when its data"]
    #[doc = " is to be modified by the function, and as a normal argument when it is only"]
    #[doc = " to be read by the function."]
    #[doc = ""]
    #[doc = " @param      v     Pointer to user's rc_vector_t struct"]
    #[doc = " @param[in]  s     scalar multiplier"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_vector_times_scalar(v: *mut rc_vector_t, s: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the vector norm defined by sum(abs(v)^p)^(1/p), where p"]
    #[doc = " is any positive real value."]
    #[doc = ""]
    #[doc = " Just like the matlab norm(v,p) function."]
    #[doc = ""]
    #[doc = " Most common norms are the 1 norm which gives the sum of absolute values of"]
    #[doc = " the vector and the 2-norm which is the square root of sum of squares. for"]
    #[doc = " infinity and -infinity norms see rc_vector_max and rc_vector_min"]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = " @param[in]  p     Which norm to use. Positive real values only."]
    #[doc = ""]
    #[doc = " @return     vector norm. Prints error message and returns -1.0f on error."]
    pub fn rc_vector_norm(v: rc_vector_t, p: f64) -> f64;
}
extern "C" {
    #[doc = " @brief      Returns the index of the maximum value in v."]
    #[doc = ""]
    #[doc = " The value contained in the returned index is the equivalent to the infinity"]
    #[doc = " norm. If the max value occurs multiple times then the index of the first"]
    #[doc = " instance is returned."]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns the index of the maximum value in v or -1 on error."]
    pub fn rc_vector_max(v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the index of the minimum value in v."]
    #[doc = ""]
    #[doc = " The value contained in the returned index is the equivalent to the -infinity"]
    #[doc = " norm. If the minimum value occurs multiple times then the index of the first"]
    #[doc = " instance is returned."]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns the index of the minimum value in v or -1 on error."]
    pub fn rc_vector_min(v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the standard deviation of the values in a vector."]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns the standard deviation or prints and error message and"]
    #[doc = " return -1.0f on error."]
    pub fn rc_vector_std_dev(v: rc_vector_t) -> f64;
}
extern "C" {
    #[doc = " @brief      Returns the mean (average) of all values in vector v or -1.0f on"]
    #[doc = " error."]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns the mean (average) of all values in vector v or -1.0f on"]
    #[doc = " error."]
    pub fn rc_vector_mean(v: rc_vector_t) -> f64;
}
extern "C" {
    #[doc = " @brief      Populates vector p with the projection of vector v onto e."]
    #[doc = ""]
    #[doc = " p is resized appropriately and any exising memory is freed to avoid memory"]
    #[doc = " leaks."]
    #[doc = ""]
    #[doc = " @param[in]  v     User's vector struct"]
    #[doc = " @param[in]  e     User's vector struct"]
    #[doc = " @param[out] p     output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success, otherwise -1."]
    pub fn rc_vector_projection(
        v: rc_vector_t,
        e: rc_vector_t,
        p: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates the dot product of two equal-length vectors."]
    #[doc = ""]
    #[doc = " @param[in]  v1    User's vector struct"]
    #[doc = " @param[in]  v2    User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns the dot product, or prints and error message and returns"]
    #[doc = " -1.0f on error."]
    pub fn rc_vector_dot_product(v1: rc_vector_t, v2: rc_vector_t) -> f64;
}
extern "C" {
    #[doc = " @brief      Computes the cross-product of two vectors, each of length 3."]
    #[doc = ""]
    #[doc = " The result is placed in vector p and and any existing memory used by p is"]
    #[doc = " freed to avoid memory leaks."]
    #[doc = ""]
    #[doc = " @param[in]  v1    User's vector struct"]
    #[doc = " @param[in]  v2    User's vector struct"]
    #[doc = " @param[out] p     resulting cross product"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success, otherwise -1."]
    pub fn rc_vector_cross_product(
        v1: rc_vector_t,
        v2: rc_vector_t,
        p: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Populates vector s with the sum of vectors v1 and v2."]
    #[doc = ""]
    #[doc = " v1 and v2 must be of the same length. Any existing memory allocated for s is"]
    #[doc = " freed and lost, new memory is allocated if necessary."]
    #[doc = ""]
    #[doc = " @param[in]  v1    User's vector struct"]
    #[doc = " @param[in]  v2    User's vector struct"]
    #[doc = " @param[out] s     output sum"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success, otherwise -1."]
    pub fn rc_vector_sum(
        v1: rc_vector_t,
        v2: rc_vector_t,
        s: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Adds vector v2 to v1 and leaves the result in v1."]
    #[doc = ""]
    #[doc = " The original contents of v1 are lost and v2 is left untouched. v1 and v2 must"]
    #[doc = " be of the same length."]
    #[doc = ""]
    #[doc = " @param      v1    User's vector struct, holds the result"]
    #[doc = " @param[in]  v2    User's vector struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success, otherwise -1."]
    pub fn rc_vector_sum_inplace(v1: *mut rc_vector_t, v2: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Populates vector s with the difference v1 - v2."]
    #[doc = ""]
    #[doc = " v1 and v2 must be of the same length. Any existing memory allocated for s is"]
    #[doc = " freed and lost, new memory is allocated if necessary."]
    #[doc = ""]
    #[doc = " @param[in]  v1    User's vector struct"]
    #[doc = " @param[in]  v2    User's vector struct"]
    #[doc = " @param[out] s     output difference v1-v2"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success, otherwise -1."]
    pub fn rc_vector_subtract(
        v1: rc_vector_t,
        v2: rc_vector_t,
        s: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief      Struct containing the state of a matrix and a pointer to"]
#[doc = " dynamically allocated memory to hold its contents."]
#[doc = ""]
#[doc = " Set and read values directly with this code:"]
#[doc = " @code{.c}"]
#[doc = " matrix.d[row][col] = new_value; // set value in the matrix"]
#[doc = " value = matrix.d[row][col];     // get value from the matrix"]
#[doc = " @endcode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_matrix_t {
    #[doc = "< number of rows in the matrix"]
    pub rows: ::std::os::raw::c_int,
    #[doc = "< number of columns in the matrix"]
    pub cols: ::std::os::raw::c_int,
    #[doc = "< pointer to allocated 2d array"]
    pub d: *mut *mut f64,
    #[doc = "< set to 1 once memory has been allocated"]
    pub initialized: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rc_matrix_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_matrix_t>(),
        16usize,
        concat!("Size of: ", stringify!(rc_matrix_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_matrix_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rc_matrix_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_matrix_t>())).rows as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_matrix_t),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_matrix_t>())).cols as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_matrix_t),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_matrix_t>())).d as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_matrix_t),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_matrix_t>())).initialized as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_matrix_t),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief      Returns an rc_matrix_t with no allocated memory and the"]
    #[doc = " initialized flag set to 0."]
    #[doc = ""]
    #[doc = " This is essential for initializing rc_matrix_t structs when they are declared"]
    #[doc = " since local variables declared in a function without global variable scope in"]
    #[doc = " C are not guaranteed to be zeroed out which can lead to bad memory pointers"]
    #[doc = " and segfaults if not handled carefully. We recommend initializing all"]
    #[doc = " matrices with this before using rc_matrix_alloc or any other function."]
    #[doc = ""]
    #[doc = " @return     Returns an empty rc_matrix_t"]
    pub fn rc_matrix_empty() -> rc_matrix_t;
}
extern "C" {
    #[doc = " @brief      Allocates memory for matrix A to have size rows&cols."]
    #[doc = ""]
    #[doc = " If A is initially the right size, nothing is done and the data in A is"]
    #[doc = " preserved. If A is uninitialized or of the wrong size then any existing"]
    #[doc = " memory is freed and new memory is allocated, helping to prevent accidental"]
    #[doc = " memory leaks. The contents of the new matrix is not guaranteed to be anything"]
    #[doc = " in particular as the memory is allocated with malloc. Will only be"]
    #[doc = " unsuccessful if rows&cols are invalid or there is insufficient memory"]
    #[doc = " available."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = " @param[in]  rows  number of rows"]
    #[doc = " @param[in]  cols  number of columns"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_alloc(
        A: *mut rc_matrix_t,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Frees the memory allocated for a matrix A"]
    #[doc = ""]
    #[doc = " Also sets the dimensions and initialized flag to 0 to indicate to other"]
    #[doc = " functions that A no longer points to allocated memory and cannot be used"]
    #[doc = " until more memory is allocated such as with rc_matrix_alloc or"]
    #[doc = " rc_matrix_zeros. Will only fail and return -1 if it is passed a NULL pointer."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_free(A: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes matrix A and allocates memory for a matrix with specified rows &"]
    #[doc = " columns. The new memory is pre-filled with zeros using calloc. Any existing memory"]
    #[doc = " allocated for A is freed if necessary to avoid memory leaks."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = " @param[in]  rows  number of rows"]
    #[doc = " @param[in]  cols  number of columns"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_zeros(
        A: *mut rc_matrix_t,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Resizes A to be a square identity matrix with dimensions"]
    #[doc = " dim-by-dim."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for A is freed if necessary to avoid memory"]
    #[doc = " leaks before new memory is allocated for the specified dimension."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = " @param[in]  dim   The dimension of one side of square matrix"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_identity(
        A: *mut rc_matrix_t,
        dim: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Generates a matrix populated with random numbers between -1 and"]
    #[doc = " 1."]
    #[doc = ""]
    #[doc = " Resizes A to be a matrix with the specified number of rows and columns and"]
    #[doc = " populates the new memory with random numbers evenly distributed between -1.0"]
    #[doc = " and 1.0. Any existing memory allocated for A is freed if necessary to avoid"]
    #[doc = " memory leaks."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = " @param[in]  rows  number of rows"]
    #[doc = " @param[in]  cols  number of columns"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_random(
        A: *mut rc_matrix_t,
        rows: ::std::os::raw::c_int,
        cols: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Generates a diagonal matrix with the elements of specified vector"]
    #[doc = " v."]
    #[doc = ""]
    #[doc = " Resizes A to be a square matrix with the same number of rows and columns as"]
    #[doc = " vector v's length. The diagonal entries of A are then populated with the"]
    #[doc = " contents of v and the off-diagonal entries are set to 0. The original"]
    #[doc = " contents of A are freed to avoid memory leaks."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to user's matrix struct"]
    #[doc = " @param[in]  v     vector of diagonal entries"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_diagonal(A: *mut rc_matrix_t, v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Duplicates the contents of matrix A and into matrix B."]
    #[doc = ""]
    #[doc = " If B is already the right size then its contents are overwritten. If B is"]
    #[doc = " unallocated or is of the wrong size then the memory is freed and new memory"]
    #[doc = " is allocated to hold the duplicate of A."]
    #[doc = ""]
    #[doc = " @param[in]  A     Matrix to be duplicated"]
    #[doc = " @param[out] B     new matrix"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_duplicate(A: rc_matrix_t, B: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints the contents of matrix A to stdout in decimal notation"]
    #[doc = " with 4 decimal places."]
    #[doc = ""]
    #[doc = " Not recommended for very large matrices as rows will typically linewrap if"]
    #[doc = " the terminal window is not wide enough."]
    #[doc = ""]
    #[doc = " @param[in]  A     Matrix to print"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_print(A: rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints the contents of matrix A to stdout in scientific notation."]
    #[doc = ""]
    #[doc = " Prints 4 significant figures. Not recommended for very large matrices as rows"]
    #[doc = " will typically linewrap if the terminal window is not wide enough."]
    #[doc = ""]
    #[doc = " @param[in]  A     Matrix to print"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_print_sci(A: rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets all values of an already-allocated matrix to 0"]
    #[doc = ""]
    #[doc = " @param      A     pointer to matrix to be zero'd out"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_matrix_zero_out(A: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies every entry in A by scalar value s."]
    #[doc = ""]
    #[doc = " It is not strictly necessary for A to be provided as a pointer since a copy"]
    #[doc = " of the struct A would also contain the correct pointer to the original"]
    #[doc = " matrix's allocated memory. However, in this library we use the convention of"]
    #[doc = " passing an rc_vector_t struct or rc_matrix_t struct as a pointer when its"]
    #[doc = " data is to be modified by the function, and as a normal argument when it is"]
    #[doc = " only to be read by the function."]
    #[doc = ""]
    #[doc = " @param      A     Matrix to be modified"]
    #[doc = " @param[in]  s     scalar to multiply by"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_times_scalar(A: *mut rc_matrix_t, s: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies A*B=C."]
    #[doc = ""]
    #[doc = " C is resized and its original contents are freed if necessary to avoid memory"]
    #[doc = " leaks."]
    #[doc = ""]
    #[doc = " @param[in]  A     first input"]
    #[doc = " @param[in]  B     second input"]
    #[doc = " @param[out] C     result"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_multiply(
        A: rc_matrix_t,
        B: rc_matrix_t,
        C: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies A*B and puts the result back in the place of B."]
    #[doc = ""]
    #[doc = " B is resized and its original contents are freed if necessary to avoid memory"]
    #[doc = " leaks."]
    #[doc = ""]
    #[doc = " @param[in]  A     left matrix in the multiplication"]
    #[doc = " @param      B     right matrix in the multiplication and holder of the"]
    #[doc = " result."]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_left_multiply_inplace(
        A: rc_matrix_t,
        B: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies A*B and puts the result back in the place of A."]
    #[doc = ""]
    #[doc = " A is resized and its original contents are freed if necessary to avoid memory"]
    #[doc = " leaks."]
    #[doc = ""]
    #[doc = " @param      A     left matrix in the multiplication and holder of result"]
    #[doc = " @param[in]  B     right matrix in the multiplication"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_right_multiply_inplace(
        A: *mut rc_matrix_t,
        B: rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Adds matrices A+B and places the result in C."]
    #[doc = ""]
    #[doc = " The original contents of C are safely freed if necessary to avoid memory"]
    #[doc = " leaks. Use rc_matrix_add_inplace if you do not need to keep the contents of"]
    #[doc = " one of these matrices after addition."]
    #[doc = ""]
    #[doc = " @param[in]  A     First matrix"]
    #[doc = " @param[in]  B     second matrix"]
    #[doc = " @param[out] C     result"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_add(
        A: rc_matrix_t,
        B: rc_matrix_t,
        C: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Adds matrix A to B and places the result back in A."]
    #[doc = ""]
    #[doc = " The original contents of A are lost. Use rc_matrix_add if you wish to keep"]
    #[doc = " the contents of both matrix A and B after addition."]
    #[doc = ""]
    #[doc = " @param      A     First matrix for addition and holder of the result"]
    #[doc = " @param[in]  B     Second matrix for addition"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_add_inplace(A: *mut rc_matrix_t, B: rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Subtracts matrix B from A and leaves the result in A"]
    #[doc = ""]
    #[doc = " The original contents of A are lost."]
    #[doc = ""]
    #[doc = " @param      A     First matrix for subtraction and holder of the result"]
    #[doc = " @param[in]  B     Second matrix for subtraction"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_subtract_inplace(A: *mut rc_matrix_t, B: rc_matrix_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Transposes the contents of A and places the result in T."]
    #[doc = ""]
    #[doc = " Resizes matrix T to hold the transposed contents of A and leaves A untouched."]
    #[doc = " Original contents of T are safely freed and lost. If the original contents of"]
    #[doc = " A are not needed after transposing then use rc_matrix_transpose_inplace"]
    #[doc = " instead."]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix struct"]
    #[doc = " @param[out] T     resulting transpose"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_transpose(A: rc_matrix_t, T: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Transposes matrix A in place."]
    #[doc = ""]
    #[doc = " Use as an alternative to rc_matrix_transpose if you no longer have need for"]
    #[doc = " the original contents of matrix A."]
    #[doc = ""]
    #[doc = " @param      A     Pointer to matrix to be transposed"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_transpose_inplace(A: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies matrix A times column vector v and places the result"]
    #[doc = " in column vector c."]
    #[doc = ""]
    #[doc = " Any existing data in c is freed if necessary and c is resized appropriately."]
    #[doc = " Vectors v and c are interpreted as column vectors, but nowhere in their"]
    #[doc = " definitions are they actually specified as one or the other."]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = " @param[in]  v     input vector"]
    #[doc = " @param[out] c     output vector"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_times_col_vec(
        A: rc_matrix_t,
        v: rc_vector_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Multiplies row vector v times matrix A and places the result in"]
    #[doc = " row vector c."]
    #[doc = ""]
    #[doc = " Any existing data in c is freed if necessary and c is resized appropriately."]
    #[doc = " Vectors v and c are interpreted as row vectors, but nowhere in their"]
    #[doc = " definitions are they actually specified as one or the other."]
    #[doc = ""]
    #[doc = " @param[in]  v     input vector"]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = " @param[out] c     output vector"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_row_vec_times_matrix(
        v: rc_vector_t,
        A: rc_matrix_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Computes v1 times v2 where v1 is a column vector and v2 is a row"]
    #[doc = " vector."]
    #[doc = ""]
    #[doc = " @param[in]  v1    Column vector v1"]
    #[doc = " @param[in]  v2    Row vector v2"]
    #[doc = " @param      A     Output matrix"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_matrix_outer_product(
        v1: rc_vector_t,
        v2: rc_vector_t,
        A: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates the determinant of square matrix A"]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = ""]
    #[doc = " @return     Returns the determinant or prints error message and returns -1.0f"]
    #[doc = " of error."]
    pub fn rc_matrix_determinant(A: rc_matrix_t) -> f64;
}
extern "C" {
    #[doc = " @brief      Symmetrizes a square matrix"]
    #[doc = ""]
    #[doc = " P_sym = (P+P^T)/2"]
    #[doc = ""]
    #[doc = " @param      P     pointer to matrix to symmetrize"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_matrix_symmetrize(P: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Performs LUP decomposition on matrix A with partial pivoting."]
    #[doc = ""]
    #[doc = " Places the result in matrices L,U,&P. Matrix A remains untouched and the"]
    #[doc = " original contents of LUP (if any) are freed and LUP are resized"]
    #[doc = " appropriately."]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = " @param[out] L     lower triangular"]
    #[doc = " @param[out] U     upper triangular"]
    #[doc = " @param[out] P     permutation matrix"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_lup_decomp(
        A: rc_matrix_t,
        L: *mut rc_matrix_t,
        U: *mut rc_matrix_t,
        P: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculate the QR decomposition of matrix A."]
    #[doc = ""]
    #[doc = " Uses householder reflection method. Matrix A remains untouched and the"]
    #[doc = " original contents of Q&R (if any) are freed and resized appropriately."]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = " @param[out] Q     orthogonal matrix output"]
    #[doc = " @param[out] R     upper triangular matrix output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_qr_decomp(
        A: rc_matrix_t,
        Q: *mut rc_matrix_t,
        R: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Inverts matrix A via LUP decomposition method."]
    #[doc = ""]
    #[doc = " Places the result in matrix Ainv. Any existing memory allocated for Ainv is"]
    #[doc = " freed if necessary and its contents are overwritten. Returns -1 if matrix is"]
    #[doc = " not invertible."]
    #[doc = ""]
    #[doc = " @param[in]  A     input matrix"]
    #[doc = " @param[out] Ainv  resulting inverted matrix"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_invert_matrix(
        A: rc_matrix_t,
        Ainv: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Inverts matrix A in place."]
    #[doc = ""]
    #[doc = " The original contents of A are lost. Returns -1 if A is not invertible."]
    #[doc = ""]
    #[doc = " @param      A     matrix to be inverted"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_invert_matrix_inplace(A: *mut rc_matrix_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Solves Ax=b for given matrix A and vector b."]
    #[doc = ""]
    #[doc = " Places the result in vector x. existing contents of x are freed and new"]
    #[doc = " memory is allocated if necessary."]
    #[doc = ""]
    #[doc = " @param[in]  A     matrix A"]
    #[doc = " @param[in]  b     column vector b"]
    #[doc = " @param[out] x     solution column vector"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_lin_system_solve(
        A: rc_matrix_t,
        b: rc_vector_t,
        x: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the zero tolerance for detecting singular matrices."]
    #[doc = ""]
    #[doc = " When inverting matrices or solving a linear system, this library first checks"]
    #[doc = " that the determinant of the matrix is non-zero. Due to the rounding errors"]
    #[doc = " that come from float-point math, we cannot check if the determinant is"]
    #[doc = " exactly zero. Instead, it is checked to be smaller in magnitude than the"]
    #[doc = " zero-tolerance."]
    #[doc = ""]
    #[doc = " The default value is 10^-8 but it can be changed here if the user is dealing"]
    #[doc = " with unusually small or large floating point values."]
    #[doc = ""]
    #[doc = " This only effects the operation of rc_algebra_invert_matrix,"]
    #[doc = " rc_algebra_invert_matrix_inplace, and rc_algebra_lin_system_solve."]
    #[doc = ""]
    #[doc = " @param[in]  tol   The zero-tolerance"]
    pub fn rc_algebra_set_zero_tolerance(tol: f64);
}
extern "C" {
    #[doc = " @brief      Finds a least-squares solution to the system Ax=b for non-square"]
    #[doc = " A using QR decomposition method."]
    #[doc = ""]
    #[doc = " Places the solution in x."]
    #[doc = ""]
    #[doc = " @param[in]  A     matrix A"]
    #[doc = " @param[in]  b     column vector b"]
    #[doc = " @param[out] x     solution column vector"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_lin_system_solve_qr(
        A: rc_matrix_t,
        b: rc_vector_t,
        x: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fits an ellipsoid to a set of points in 3D space."]
    #[doc = ""]
    #[doc = " The principle axes of the fitted ellipsoid align with the global coordinate"]
    #[doc = " system. Therefore there are 6 degrees of freedom defining the ellipsoid: the"]
    #[doc = " x,y,z coordinates of the centroid and the lengths from the centroid to the"]
    #[doc = " surface in each of the 3 directions."]
    #[doc = ""]
    #[doc = " rc_matrix_t 'points' is a tall matrix with 3 columns and at least 6 rows."]
    #[doc = " Each row must contain the x,y&z components of each individual point to be"]
    #[doc = " fit. If only 6 rows are provided, the resulting ellipsoid will be an exact"]
    #[doc = " fit. Otherwise the result is a least-squares fit to the over-defined dataset."]
    #[doc = ""]
    #[doc = " The final x,y,z position of the centroid will be placed in vector 'center'"]
    #[doc = " and the lengths or radius from the centroid to the surface along each axis"]
    #[doc = " will be placed in the vector 'lengths'"]
    #[doc = ""]
    #[doc = " @param[in]  points   datapoints to fit"]
    #[doc = " @param[out] center   center of ellipse"]
    #[doc = " @param[out] lengths  lengths along principle axis"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_algebra_fit_ellipsoid(
        points: rc_matrix_t,
        center: *mut rc_vector_t,
        lengths: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
#[doc = " @brief      Struct containing state of a ringbuffer and pointer to"]
#[doc = " dynamically allocated memory."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_ringbuf_t {
    #[doc = "< pointer to dynamically allocated data"]
    pub d: *mut f64,
    #[doc = "< number of elements the buffer can hold"]
    pub size: ::std::os::raw::c_int,
    #[doc = "< index of the most recently added value"]
    pub index: ::std::os::raw::c_int,
    #[doc = "< flag indicating if memory has been allocated for the buffer"]
    pub initialized: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rc_ringbuf_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_ringbuf_t>(),
        16usize,
        concat!("Size of: ", stringify!(rc_ringbuf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_ringbuf_t>(),
        4usize,
        concat!("Alignment of ", stringify!(rc_ringbuf_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_ringbuf_t>())).d as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_ringbuf_t),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_ringbuf_t>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_ringbuf_t),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_ringbuf_t>())).index as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_ringbuf_t),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_ringbuf_t>())).initialized as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_ringbuf_t),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief      Returns an rc_ringbuf_t struct which is completely zero'd out"]
    #[doc = " with no memory allocated for it."]
    #[doc = ""]
    #[doc = " This is essential for declaring new ring buffers since structs declared"]
    #[doc = " inside of functions are not necessarily zero'd out which can cause the struct"]
    #[doc = " to contain problematic contents leading to segfaults. New ring buffers should"]
    #[doc = " be initialized with this before calling rc_ringbuf_alloc."]
    #[doc = ""]
    #[doc = " @return     empty and ready-to-allocate rc_ringbuf_t"]
    pub fn rc_ringbuf_empty() -> rc_ringbuf_t;
}
extern "C" {
    #[doc = " @brief      Allocates memory for a ring buffer and initializes an"]
    #[doc = " rc_ringbuf_t struct."]
    #[doc = ""]
    #[doc = " If buf is already the right size then it is left untouched. Otherwise any"]
    #[doc = " existing memory allocated for buf is freed to avoid memory leaks and new"]
    #[doc = " memory is allocated."]
    #[doc = ""]
    #[doc = " @param      buf   Pointer to user's buffer"]
    #[doc = " @param[in]  size  Number of elements to allocate space for"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_ringbuf_alloc(
        buf: *mut rc_ringbuf_t,
        size: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Frees the memory allocated for buffer buf."]
    #[doc = ""]
    #[doc = " Also set the initialized flag to 0 so other functions don't try to access"]
    #[doc = " unallocated memory."]
    #[doc = ""]
    #[doc = " @param      buf   Pointer to user's buffer"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_ringbuf_free(buf: *mut rc_ringbuf_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets all values in the buffer to 0.0f and sets the buffer index"]
    #[doc = " back to 0."]
    #[doc = ""]
    #[doc = " @param      buf   Pointer to user's buffer"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_ringbuf_reset(buf: *mut rc_ringbuf_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Puts a new float into the ring buffer and updates the index"]
    #[doc = " accordingly."]
    #[doc = ""]
    #[doc = " If the buffer was full then the oldest value in the buffer is automatically"]
    #[doc = " removed."]
    #[doc = ""]
    #[doc = " @param      buf   Pointer to user's buffer"]
    #[doc = " @param[in]  val   The value to be inserted"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_ringbuf_insert(buf: *mut rc_ringbuf_t, val: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fetches the float which is 'position' steps behind the last value"]
    #[doc = " added to the buffer."]
    #[doc = ""]
    #[doc = " If 'position' is given as 0 then the most recent value is returned. The"]
    #[doc = " position obviously can't be larger than (buffer size - 1)."]
    #[doc = ""]
    #[doc = " @param      buf       Pointer to user's buffer"]
    #[doc = " @param[in]  position  steps back in the buffer to fetch the value from"]
    #[doc = ""]
    #[doc = " @return     Returns the requested float. Prints an error message and returns"]
    #[doc = " -1.0f on error."]
    pub fn rc_ringbuf_get_value(buf: *mut rc_ringbuf_t, position: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief      Returns the standard deviation of all values in the ring buffer."]
    #[doc = ""]
    #[doc = " Note that if the buffer has not yet been filled completely before calling"]
    #[doc = " this, then the starting values of 0.0f in the unfilled portion of the buffer"]
    #[doc = " will still be part of the calculation."]
    #[doc = ""]
    #[doc = " @param[in]  buf   Pointer to user's buffer"]
    #[doc = ""]
    #[doc = " @return     Returns the standard deviation of all values in the ring buffer."]
    pub fn rc_ringbuf_std_dev(buf: rc_ringbuf_t) -> f64;
}
#[doc = " @brief      Struct containing configuration and state of a SISO filter."]
#[doc = ""]
#[doc = " Also points to dynamically allocated memory which make it necessary to use"]
#[doc = " the allocation and free function in this API for proper use. The user can"]
#[doc = " read and modify values directly from ths struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_filter_t {
    #[doc = "< transfer function order"]
    pub order: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
    #[doc = "< timestep in seconds"]
    pub dt: f64,
    #[doc = "< Additional gain multiplier, usually 1.0"]
    pub gain: f64,
    #[doc = "< numerator coefficients"]
    pub num: rc_vector_t,
    #[doc = "< denominator coefficients"]
    pub den: rc_vector_t,
    #[doc = "< set to 1 by enable_saturation()"]
    pub sat_en: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u32,
    #[doc = "< lower saturation limit"]
    pub sat_min: f64,
    #[doc = "< upper saturation limit"]
    pub sat_max: f64,
    #[doc = "< 1 if saturated on the last step"]
    pub sat_flag: ::std::os::raw::c_int,
    #[doc = "< set to 1 by enbale_soft_start()"]
    pub ss_en: ::std::os::raw::c_int,
    #[doc = "< steps before full output allowed"]
    pub ss_steps: f64,
    #[doc = " @name dynamically allocated ring buffers */"]
    pub in_buf: rc_ringbuf_t,
    pub out_buf: rc_ringbuf_t,
    #[doc = "< shortcut for the most recent input"]
    pub newest_input: f64,
    #[doc = "< shortcut for the most recent output"]
    pub newest_output: f64,
    #[doc = "< steps since last reset"]
    pub step: u64,
    #[doc = "< initialization flag"]
    pub initialized: ::std::os::raw::c_int,
    pub __bindgen_padding_2: u32,
}
#[test]
fn bindgen_test_layout_rc_filter_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_filter_t>(),
        152usize,
        concat!("Size of: ", stringify!(rc_filter_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_filter_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rc_filter_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).dt as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(dt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).gain as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(gain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).num as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).den as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(den)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).sat_en as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(sat_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).sat_min as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(sat_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).sat_max as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(sat_max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).sat_flag as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(sat_flag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).ss_en as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(ss_en)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).ss_steps as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(ss_steps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).in_buf as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(in_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).out_buf as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(out_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).newest_input as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(newest_input)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).newest_output as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(newest_output)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).step as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_filter_t>())).initialized as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_filter_t),
            "::",
            stringify!(initialized)
        )
    );
}
extern "C" {
    #[doc = " @brief      Critical function for initializing rc_filter_t structs."]
    #[doc = ""]
    #[doc = " This is a very important function. If your rc_filter_t struct is not a global"]
    #[doc = " variable, then its initial contents cannot be guaranteed to be anything in"]
    #[doc = " particular. Therefore it could contain problematic contents which could"]
    #[doc = " interfere with functions in this library. Therefore, you should always"]
    #[doc = " initialize your filters with rc_filter_empty before using with any other"]
    #[doc = " function in this library such as rc_filter_alloc. This serves the same"]
    #[doc = " purpose as rc_matrix_empty, rc_vector_empty, and rc_ringbuf_empty."]
    #[doc = ""]
    #[doc = " @return     Empty zero-filled rc_filter_t struct"]
    pub fn rc_filter_empty() -> rc_filter_t;
}
extern "C" {
    #[doc = " @brief      Allocate memory for a discrete-time filter & populates it with"]
    #[doc = " the transfer function coefficients provided in vectors num and den."]
    #[doc = ""]
    #[doc = " The memory in num and den is duplicated so those vectors can be reused or"]
    #[doc = " freed after allocating a filter without fear of disturbing the function of"]
    #[doc = " the filter. Argument dt is the timestep in seconds at which the user expects"]
    #[doc = " to operate the filter. The length of demonimator den must be at least as"]
    #[doc = " large as numerator num to avoid describing an improper transfer function. If"]
    #[doc = " rc_filter_t pointer f points to an existing filter then the old filter's"]
    #[doc = " contents are freed safely to avoid memory leaks. We suggest initializing"]
    #[doc = " filter f with rc_filter_empty before calling this function if it is not a"]
    #[doc = " global variable to ensure it does not accidentally contain invlaid contents"]
    #[doc = " such as null pointers. The filter's order is derived from the length of the"]
    #[doc = " denominator polynomial."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  num   The numerator vector"]
    #[doc = " @param[in]  den   The denomenator vector"]
    #[doc = " @param[in]  dt    Timestep in seconds"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_filter_alloc(
        f: *mut rc_filter_t,
        num: rc_vector_t,
        den: rc_vector_t,
        dt: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Like rc_filter_alloc(), but takes arrays for the numerator and"]
    #[doc = " denominator coefficients instead of vectors."]
    #[doc = ""]
    #[doc = " Arrays num and den must have lengths that form a proper or semi-proper"]
    #[doc = " transfer function."]
    #[doc = ""]
    #[doc = " @param[out] f       Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt      Timestep in seconds"]
    #[doc = " @param[in]  num     pointer to numerator array"]
    #[doc = " @param[in]  numlen  The numerator length"]
    #[doc = " @param[in]  den     pointer to denominator array"]
    #[doc = " @param[in]  denlen  The denominator length"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_filter_alloc_from_arrays(
        f: *mut rc_filter_t,
        dt: f64,
        num: *mut f64,
        numlen: ::std::os::raw::c_int,
        den: *mut f64,
        denlen: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      duplicates a filter"]
    #[doc = ""]
    #[doc = " This allocates new memory in filter f so it can be used independently from"]
    #[doc = " the old filter but with the same configuration."]
    #[doc = ""]
    #[doc = " @param      f     new filter to allocate"]
    #[doc = " @param[in]  old   old filter to copy"]
    #[doc = ""]
    #[doc = " @return     { description_of_the_return_value }"]
    pub fn rc_filter_duplicate(f: *mut rc_filter_t, old: rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Frees the memory allocated by a filter's buffers and coefficient"]
    #[doc = " vectors. Also resets all filter properties back to 0."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_free(f: *mut rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints the transfer function and other statistic of a filter to"]
    #[doc = " the screen."]
    #[doc = ""]
    #[doc = " Only works on filters up to order 9."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_print(f: rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      March a filter forward one step with new input provided as an"]
    #[doc = " argument."]
    #[doc = ""]
    #[doc = " If saturation or soft-start are enabled then the output will automatically be"]
    #[doc = " bound appropriately. The steps counter is incremented by one and internal"]
    #[doc = " ring buffers are updated accordingly. Once a filter is created, this is"]
    #[doc = " typically the only function required afterwards."]
    #[doc = ""]
    #[doc = " @param      f          Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  new_input  The new input"]
    #[doc = ""]
    #[doc = " @return     Returns the new output which could also be accessed with the"]
    #[doc = " newest_output field in the filter struct."]
    pub fn rc_filter_march(f: *mut rc_filter_t, new_input: f64) -> f64;
}
extern "C" {
    #[doc = " @brief      Resets all previous inputs and outputs to 0. Also resets the step"]
    #[doc = " counter & saturation flag."]
    #[doc = ""]
    #[doc = " This is sufficient to start the filter again as if it were just created."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_reset(f: *mut rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Enables saturation between bounds min and max."]
    #[doc = ""]
    #[doc = " If saturation is enabled for a specified filter, the filter will"]
    #[doc = " automatically bound the output between min and max. You may ignore this"]
    #[doc = " function if you wish the filter to run unbounded. Max must be greater than or"]
    #[doc = " equal to min. If max==min, the output will be fixed at that value. Any"]
    #[doc = " double-precision floating point value is allowed, positive or negative."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  min   The lower bound"]
    #[doc = " @param[in]  max   The upper bound"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_enable_saturation(
        f: *mut rc_filter_t,
        min: f64,
        max: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Checks if the filter saturated the last time step."]
    #[doc = ""]
    #[doc = " This information could also be retrieved by looking at the 'sat_flag' value"]
    #[doc = " in the filter struct."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 1 if the filter saturated the last time step. Returns 0"]
    #[doc = " otherwise."]
    pub fn rc_filter_get_saturation_flag(f: *mut rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Enables soft start functionality where the output bound is"]
    #[doc = " gradually opened linearly from 0 to the normal saturation range."]
    #[doc = ""]
    #[doc = " This occurs over the time specified from argument 'seconds' from when the"]
    #[doc = " filter is first created or reset. Saturation must already be enabled for this"]
    #[doc = " to work. This assumes that the user does indeed call rc_filter_march at"]
    #[doc = " roughly the same time interval as the 'dt' variable in the filter struct"]
    #[doc = " which is set at creation time. The soft-start property is maintained through"]
    #[doc = " a call to rc_filter_reset so the filter will soft-start again after each"]
    #[doc = " reset. This feature should only really be used for feedback controllers to"]
    #[doc = " prevent jerky starts. The saturation flag will not be set during this period"]
    #[doc = " as the output is usually expected to be bounded and we don't want to falsely"]
    #[doc = " trigger alarms or saturation counters."]
    #[doc = ""]
    #[doc = " @param      f        Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  seconds  Time in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_enable_soft_start(f: *mut rc_filter_t, seconds: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the input 'steps' back in time. Steps=0 returns most"]
    #[doc = " recent input."]
    #[doc = ""]
    #[doc = " 'steps' must be between 0 and order inclusively as those are the only steps"]
    #[doc = " retained in memory for normal filter operation. To record values further back"]
    #[doc = " in time we suggest creating your own rc_ringbuf_t ring buffer."]
    #[doc = ""]
    #[doc = " @param      f      Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  steps  The steps back in time, steps=0 returns most recent input."]
    #[doc = ""]
    #[doc = " @return     Returns the requested previous input. If there is an error,"]
    #[doc = " returns -1.0f and prints an error message."]
    pub fn rc_filter_previous_input(f: *mut rc_filter_t, steps: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief      Returns the output 'steps' back in time. Steps = 0 returns most"]
    #[doc = " recent output."]
    #[doc = ""]
    #[doc = " 'steps' must be between 0 and order inclusively as those are the only steps"]
    #[doc = " retained in memory for normal filter operation. To record values further back"]
    #[doc = " in time we suggest creating your own rc_ringbuf_t ring buffer."]
    #[doc = ""]
    #[doc = " @param      f      Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  steps  The steps back in time, steps=0 returns most recent"]
    #[doc = " output."]
    #[doc = ""]
    #[doc = " @return     Returns the requested previous output. If there is an error,"]
    #[doc = " returns -1.0f and prints an error message."]
    pub fn rc_filter_previous_output(f: *mut rc_filter_t, steps: ::std::os::raw::c_int) -> f64;
}
extern "C" {
    #[doc = " @brief      Fills all previous inputs to the filter as if they had been equal"]
    #[doc = " to 'in'"]
    #[doc = ""]
    #[doc = " Most useful when starting high-pass filters to prevent unwanted jumps in the"]
    #[doc = " output when starting with non-zero input."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  in    Input value to fill"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_prefill_inputs(f: *mut rc_filter_t, in_: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fills all previous outputs of the filter as if they had been"]
    #[doc = " equal to 'out'."]
    #[doc = ""]
    #[doc = " Most useful when starting low-pass filters to prevent unwanted settling time"]
    #[doc = " when starting with non-zero input."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  out   output value to fill"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_prefill_outputs(f: *mut rc_filter_t, out: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a new filter 'out' by multiplying f1*f2."]
    #[doc = ""]
    #[doc = " The contents of f3 are freed safely if necessary and new memory is allocated"]
    #[doc = " to avoid memory leaks."]
    #[doc = ""]
    #[doc = " @param[in]  f1    Pointer to user's rc_filter_t struct to be multiplied"]
    #[doc = " @param[in]  f2    Pointer to user's rc_filter_t struct to be multiplied"]
    #[doc = " @param[out] out   Pointer to newly created filter struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_multiply(
        f1: rc_filter_t,
        f2: rc_filter_t,
        out: *mut rc_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a new filter 'out' by multiplying f1*f2*f3"]
    #[doc = ""]
    #[doc = " The contents of f3 are freed safely if necessary and new memory is allocated"]
    #[doc = " to avoid memory leaks."]
    #[doc = ""]
    #[doc = " @param[in]  f1    Pointer to user's rc_filter_t struct to be multiplied"]
    #[doc = " @param[in]  f2    Pointer to user's rc_filter_t struct to be multiplied"]
    #[doc = " @param[in]  f3    Pointer to user's rc_filter_t struct to be multiplied"]
    #[doc = " @param[out] out   Pointer to newly created filter struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_multiply_three(
        f1: rc_filter_t,
        f2: rc_filter_t,
        f3: rc_filter_t,
        out: *mut rc_filter_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a discrete time filter with similar dynamics to a"]
    #[doc = " provided continuous time transfer function using tustin's approximation with"]
    #[doc = " prewarping about a frequency of interest 'w' in radians per second."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed is necessary to prevent memory"]
    #[doc = " leaks. Returns 0 on success or -1 on failure."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = " @param[in]  num   continuous time numerator coefficients"]
    #[doc = " @param[in]  den   continuous time denominator coefficients"]
    #[doc = " @param[in]  w     prewarping frequency in rad/s"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_c2d_tustin(
        f: *mut rc_filter_t,
        dt: f64,
        num: rc_vector_t,
        den: rc_vector_t,
        w: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Normalizes a discrete time filter so that the leading demoninator"]
    #[doc = " coefficient is 1"]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_normalize(f: *mut rc_filter_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a first order low pass filter."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed safely to avoid memory leaks and"]
    #[doc = " new memory is allocated for the new filter. dt is in units of seconds and"]
    #[doc = " time_constant is the number of seconds it takes to rise to 63.4% of a"]
    #[doc = " steady-state input. This can be used alongside rc_first_order_highpass to"]
    #[doc = " make a complementary filter pair."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = " @param[in]  tc    time constant: Seconds it takes to rise to 63.4% of a"]
    #[doc = " steady-state input"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_first_order_lowpass(
        f: *mut rc_filter_t,
        dt: f64,
        tc: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a first order high pass filter."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed safely to avoid memory leaks and"]
    #[doc = " new memory is allocated for the new filter. dt is in units of seconds and"]
    #[doc = " time_constant is the number of seconds it takes to decay by 63.4% of a"]
    #[doc = " steady-state input. This can be used alongside rc_first_order_highpass to"]
    #[doc = " make a complementary filter pair."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = " @param[in]  tc    time constant: Seconds it takes to decay by 63.4% of a"]
    #[doc = " steady-state input"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_first_order_highpass(
        f: *mut rc_filter_t,
        dt: f64,
        tc: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a Butterworth low pass filter of specified order and"]
    #[doc = " cutoff frequency."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed safely to avoid memory leaks and"]
    #[doc = " new memory is allocated for the new filter."]
    #[doc = ""]
    #[doc = " @param[out] f      Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  order  The order (>=1)"]
    #[doc = " @param[in]  dt     desired timestep of discrete filter in seconds"]
    #[doc = " @param[in]  wc     Cuttoff freqauency in rad/s"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_butterworth_lowpass(
        f: *mut rc_filter_t,
        order: ::std::os::raw::c_int,
        dt: f64,
        wc: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a Butterworth high pass filter of specified order and"]
    #[doc = " cutoff frequency."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed safely to avoid memory leaks and"]
    #[doc = " new memory is allocated for the new filter."]
    #[doc = ""]
    #[doc = " @param[out] f      Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  order  The order (>=1)"]
    #[doc = " @param[in]  dt     desired timestep of discrete filter in seconds"]
    #[doc = " @param[in]  wc     Cuttoff freqauency in rad/s"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_butterworth_highpass(
        f: *mut rc_filter_t,
        order: ::std::os::raw::c_int,
        dt: f64,
        wc: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Makes a FIR moving average filter that averages over specified"]
    #[doc = " number of samples."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for f is freed safely to avoid memory leaks and"]
    #[doc = " new memory is allocated for the new filter."]
    #[doc = ""]
    #[doc = " Note that the timestep dt does not effect the dynamics of the produced"]
    #[doc = " filter. It is simply copied into the 'dt' field of the rc_filter_t struct."]
    #[doc = " However, it is necessary for creation of this filter for compatability with"]
    #[doc = " the soft-start feature and any other user codepaths that may be dependent on"]
    #[doc = " a filter's timestep."]
    #[doc = ""]
    #[doc = " @param[out] f        Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  samples  The samples to average over (>=2)"]
    #[doc = " @param[in]  dt       desired timestep of discrete filter in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_moving_average(
        f: *mut rc_filter_t,
        samples: ::std::os::raw::c_int,
        dt: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a first order integrator."]
    #[doc = ""]
    #[doc = " Like most functions here, the dynamics are only accurate if the filter is"]
    #[doc = " called with a timestep corresponding to dt. Any existing memory allocated for"]
    #[doc = " f is freed safely to avoid memory leaks and new memory is allocated for the"]
    #[doc = " new filter."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_integrator(f: *mut rc_filter_t, dt: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a second order double integrator."]
    #[doc = ""]
    #[doc = " Like most functions here, the dynamics are only accurate if the filter is"]
    #[doc = " called with a timestep corresponding to dt. Any existing memory allocated for"]
    #[doc = " f is freed safely to avoid memory leaks and new memory is allocated for the"]
    #[doc = " new filter."]
    #[doc = ""]
    #[doc = " @param[out] f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_double_integrator(f: *mut rc_filter_t, dt: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a discrete-time implementation of a parallel PID"]
    #[doc = " controller with high-frequency rolloff using the forward-Euler integration"]
    #[doc = " method."]
    #[doc = ""]
    #[doc = " This is equivalent to the Matlab function: C = pid(Kp,Ki,Kd,Tf,Ts)"]
    #[doc = ""]
    #[doc = " It is not possible to implement a pure differentiator with a discrete"]
    #[doc = " transfer function so this filter has high frequency rolloff with time"]
    #[doc = " constant Tf. Smaller Tf results in less rolloff, but Tf must be greater than"]
    #[doc = " dt/2 for stability. Returns 0 on success or -1 on failure."]
    #[doc = ""]
    #[doc = " @param      f     Pointer to user's rc_filter_t struct"]
    #[doc = " @param[in]  kp    Proportional constant"]
    #[doc = " @param[in]  ki    Integration constant"]
    #[doc = " @param[in]  kd    Derivative constant"]
    #[doc = " @param[in]  Tf    High Frequency rolloff time constant (seconds)"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_filter_pid(
        f: *mut rc_filter_t,
        kp: f64,
        ki: f64,
        kd: f64,
        Tf: f64,
        dt: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Creates a third order symmetric complementary pair of high/low"]
    #[doc = " pass filters"]
    #[doc = ""]
    #[doc = " @param      lp    lowpass filter to be populated"]
    #[doc = " @param      hp    highpass filter to be populated"]
    #[doc = " @param[in]  freq  crossover frequency in rad/s"]
    #[doc = " @param[in]  damp  Damping ratio >0, 1 is critically damped, lower than that"]
    #[doc = " gets wobbly"]
    #[doc = " @param[in]  dt    desired timestep of discrete filter in seconds"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_filter_third_order_complement(
        lp: *mut rc_filter_t,
        hp: *mut rc_filter_t,
        freq: f64,
        damp: f64,
        dt: f64,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_kalman_t {
    #[doc = "< undriven state-transition model"]
    pub F: rc_matrix_t,
    #[doc = "< control input model"]
    pub G: rc_matrix_t,
    #[doc = "< observation-model"]
    pub H: rc_matrix_t,
    #[doc = "< Process noise covariance set by user"]
    pub Q: rc_matrix_t,
    #[doc = "< Measurement noise covariance set by user"]
    pub R: rc_matrix_t,
    #[doc = "< Predicted state error covariance calculated by the update functions"]
    pub P: rc_matrix_t,
    #[doc = "< Initial P matrix set by user"]
    pub Pi: rc_matrix_t,
    #[doc = "< Estimated state x[k|k]   = x[k|k-1],y[k])"]
    pub x_est: rc_vector_t,
    #[doc = "< Predicted state x[k|k-1] = f(x[k-1],u[k])"]
    pub x_pre: rc_vector_t,
    #[doc = "< set to 1 once initialized with rc_kalman_alloc"]
    pub initialized: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
    #[doc = "< counts times rc_kalman_measurement_update has been called"]
    pub step: u64,
}
#[test]
fn bindgen_test_layout_rc_kalman_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_kalman_t>(),
        152usize,
        concat!("Size of: ", stringify!(rc_kalman_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_kalman_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rc_kalman_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).F as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(F)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).G as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(G)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).H as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(H)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).Q as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(Q)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).R as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(R)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).P as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(P)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).Pi as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(Pi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).x_est as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(x_est)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).x_pre as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(x_pre)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).initialized as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(initialized)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_kalman_t>())).step as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_kalman_t),
            "::",
            stringify!(step)
        )
    );
}
extern "C" {
    #[doc = " @brief      Critical function for initializing rc_kalman_t structs"]
    #[doc = ""]
    #[doc = " This is a very important function. If your rc_kalman_t struct is not a global"]
    #[doc = " variable, then its initial contents cannot be guaranteed to be anything in"]
    #[doc = " particular. Therefore it could contain problematic contents which could"]
    #[doc = " interfere with functions in this library. Therefore, you should always"]
    #[doc = " initialize your filters with rc_kalman_empty() before using with any other"]
    #[doc = " function in this library such as rc_kalman_alloc. This serves the same"]
    #[doc = " purpose as rc_matrix_empty, rc_vector_empty, rc_filter_empty, and"]
    #[doc = " rc_ringbuf_empty."]
    #[doc = ""]
    #[doc = " @return     Empty zero-filled rc_kalman_t struct"]
    pub fn rc_kalman_empty() -> rc_kalman_t;
}
extern "C" {
    #[doc = " @brief      Allocates memory for a Kalman filter of given dimensions"]
    #[doc = ""]
    #[doc = " @param      kf    pointer to struct to be allocated"]
    #[doc = " @param[in]  F     undriven state-transition model"]
    #[doc = " @param[in]  G     control input model"]
    #[doc = " @param[in]  H     observation model"]
    #[doc = " @param[in]  Q     Process noise covariance, can be updated later"]
    #[doc = " @param[in]  R     Measurement noise covariance, can be updated later"]
    #[doc = " @param[in]  Pi    Initial P matrix"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_kalman_alloc_lin(
        kf: *mut rc_kalman_t,
        F: rc_matrix_t,
        G: rc_matrix_t,
        H: rc_matrix_t,
        Q: rc_matrix_t,
        R: rc_matrix_t,
        Pi: rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Allocates memory for a Kalman filter of given dimensions"]
    #[doc = ""]
    #[doc = " @param      kf    pointer to struct to be allocated"]
    #[doc = " @param[in]  Q     Process noise covariance, can be updated later"]
    #[doc = " @param[in]  R     Measurement noise covariance, can be updated later"]
    #[doc = " @param[in]  Pi    Initial P matrix"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_kalman_alloc_ekf(
        kf: *mut rc_kalman_t,
        Q: rc_matrix_t,
        R: rc_matrix_t,
        Pi: rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Frees the memory allocated by a kalman filter's matrices and"]
    #[doc = "             vectors. Also resets all values to 0 like rc_kalman_empty()."]
    #[doc = ""]
    #[doc = " @param      kf    pointer to user's rc_kalman_t struct"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_kalman_free(kf: *mut rc_kalman_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      reset state and dynamics of the filter to 0"]
    #[doc = ""]
    #[doc = " Q and R are constant, and therefore not reset. P is set to identity*P_init."]
    #[doc = ""]
    #[doc = " @param      kf    pointer to struct to be reset"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_kalman_reset(kf: *mut rc_kalman_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Kalman Filter state prediction step based on physical model."]
    #[doc = ""]
    #[doc = " Uses the state estimate and control input from the previous timestep to"]
    #[doc = " produce an estimate of the state at the current timestep. This step pdates P"]
    #[doc = " and the estimated state x. Assume that you have calculated f(x[k|k],u[k]) and"]
    #[doc = " F(x[k|k],u[k]) before calling this function."]
    #[doc = ""]
    #[doc = " - Kalman linear state prediction"]
    #[doc = "   - x_pre[k|k-1] = F*x[k-1|k-1] +  G*u[k-1]"]
    #[doc = "   - P[k|k-1] = F*P[k-1|k-1]*F^T + Q"]
    #[doc = " - Kalman measurement Update:"]
    #[doc = "   - h[k] = H * x_pre[k]"]
    #[doc = "   - S = H*P*H^T + R"]
    #[doc = "   - L = P*(H^T)*(S^-1)"]
    #[doc = "   - x_est[k|k] = x[k|k-1] + L*(y[k]-h[k])"]
    #[doc = "   - P[k|k] = (I - L*H)*P[k|k-1]"]
    #[doc = ""]
    #[doc = " @param      kf    pointer to struct to be updated"]
    #[doc = " @param      u     control input"]
    #[doc = " @param[in]  y     sensor measurement"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_kalman_update_lin(
        kf: *mut rc_kalman_t,
        u: rc_vector_t,
        y: rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Kalman Filter measurement update step."]
    #[doc = ""]
    #[doc = " Updates L, P, & x_est. Assumes that you have done the non-linear prediction"]
    #[doc = " step in your own function which should calculate the Jacobians F(x[k|k-1]) &"]
    #[doc = " H(x[k|k-1]), the predicted sensor value h(x[k|k-1]), and of course the"]
    #[doc = " predicted state x_pre[k|k-1]"]
    #[doc = ""]
    #[doc = " -Kalman measurement Update:"]
    #[doc = " - P[k|k-1] = F*P[k-1|k-1]*F^T + Q"]
    #[doc = " - S = H*P*H^T + R"]
    #[doc = " - L = P*(H^T)*(S^-1)"]
    #[doc = " - x[k|k] = x[k|k-1] + L*y"]
    #[doc = " - P[k|k] = (I - L*H)*P"]
    #[doc = ""]
    #[doc = " Also updates the step counter in the rc_kalman_t struct"]
    #[doc = ""]
    #[doc = " @param      kf     pointer to struct to be updated"]
    #[doc = " @param[in]  F      Jacobian of state transition matrix linearized at x_pre"]
    #[doc = " @param[in]  H      Jacobian of observation matrix linearized at x_pre"]
    #[doc = " @param[in]  x_pre  predicted state"]
    #[doc = " @param[in]  y      new sensor data"]
    #[doc = " @param[in]  h      Ideal estimate of y, usually h=H*x_pre."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_kalman_update_ekf(
        kf: *mut rc_kalman_t,
        F: rc_matrix_t,
        H: rc_matrix_t,
        x_pre: rc_vector_t,
        y: rc_vector_t,
        h: rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns a random floating point number between -1 and 1."]
    #[doc = ""]
    #[doc = " Uses standard C rand function and bitwise operations which is much faster"]
    #[doc = " than doing floating point arithmetic."]
    #[doc = ""]
    #[doc = " @return     random floating point number between -1 and 1"]
    pub fn rc_get_random_float() -> f32;
}
extern "C" {
    #[doc = " @brief      Returns a random double-precision floating point number between"]
    #[doc = " -1 and 1."]
    #[doc = ""]
    #[doc = " Uses standard C rand function and bitwise operations which is much faster"]
    #[doc = " than doing floating point arithmetic."]
    #[doc = ""]
    #[doc = " @return     random double-precision floating point number between -1 and 1"]
    pub fn rc_get_random_double() -> f64;
}
extern "C" {
    #[doc = " @brief      Modifies val to be bounded between between min and max."]
    #[doc = ""]
    #[doc = " @param      val   The value to be checked and possibly modified"]
    #[doc = " @param[in]  min   The lower bound"]
    #[doc = " @param[in]  max   The upper bound"]
    #[doc = ""]
    #[doc = " @return     Returns 1 if saturation occurred, 0 if val was already in bound,"]
    #[doc = " and -1 if min was falsely larger than max."]
    pub fn rc_saturate_float(val: *mut f32, min: f32, max: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Modifies val to be bounded between between min and max."]
    #[doc = ""]
    #[doc = " @param      val   The value to be checked and possibly modified"]
    #[doc = " @param[in]  min   The lower bound"]
    #[doc = " @param[in]  max   The upper bound"]
    #[doc = ""]
    #[doc = " @return     Returns 1 if saturation occurred, 0 if val was already in bound,"]
    #[doc = " and -1 if min was falsely larger than max."]
    pub fn rc_saturate_double(val: *mut f64, min: f64, max: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints a polynomial in human-readable format in one line."]
    #[doc = ""]
    #[doc = " Like rc_print_vector, but assumes the contents represent a polynomial and"]
    #[doc = " prints the coefficients with trailing powers of x for easier reading. This"]
    #[doc = " relies on your terminal supporting unicode UTF-8. numer of coefficients and"]
    #[doc = " there the length of vector v must be less than or equal to 10."]
    #[doc = ""]
    #[doc = " @param[in]  v     polynomial coefficients to be printed"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_poly_print(v: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Convolutes the polynomials a&b and places the result in vector c."]
    #[doc = ""]
    #[doc = " This finds the coefficients of the polynomials resulting from multiply a*b."]
    #[doc = " The original contents of c are freed and new memory is allocated if"]
    #[doc = " necessary."]
    #[doc = ""]
    #[doc = " @param[in]  a     First set of coefficients"]
    #[doc = " @param[in]  b     Second set of coefficients"]
    #[doc = " @param[out] c     Vector to output resulting coefficients"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_poly_conv(
        a: rc_vector_t,
        b: rc_vector_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Raises a polynomial a to itself n times where n is greater than"]
    #[doc = " or equal to 0."]
    #[doc = ""]
    #[doc = " Places the result in vector b, any existing memory allocated for b is freed"]
    #[doc = " and its contents are lost. Returns 0 on success and -1 on failure."]
    #[doc = ""]
    #[doc = " @param[in]  a     Initial coefficients"]
    #[doc = " @param[in]  n     Power, must be >=0"]
    #[doc = " @param[out] b     resulting coefficients"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_poly_power(
        a: rc_vector_t,
        n: ::std::os::raw::c_int,
        b: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Add two polynomials a&b with right justification and place the"]
    #[doc = " result in c."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for c is freed and its contents are lost."]
    #[doc = ""]
    #[doc = " @param[in]  a     First input"]
    #[doc = " @param[in]  b     second input"]
    #[doc = " @param[out] c     output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_add(
        a: rc_vector_t,
        b: rc_vector_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Adds polynomials a&b with right justification."]
    #[doc = ""]
    #[doc = " The result is placed in vector a and a's original contents are lost. More"]
    #[doc = " memory is allocated for a if necessary."]
    #[doc = ""]
    #[doc = " @param      a     First input and where output is written"]
    #[doc = " @param[in]  b     second input"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_add_inplace(a: *mut rc_vector_t, b: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Subtracts two polynomials a-b with right justification and places"]
    #[doc = " the result in c."]
    #[doc = ""]
    #[doc = " Any existing memory allocated for c is freed and its contents are lost."]
    #[doc = " Returns 0 on success and -1 on failure."]
    #[doc = ""]
    #[doc = " @param[in]  a     First input"]
    #[doc = " @param[in]  b     second input"]
    #[doc = " @param[out] c     output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_subtract(
        a: rc_vector_t,
        b: rc_vector_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Subtracts b from a with right justification."]
    #[doc = ""]
    #[doc = " a stays in place and new memory is allocated only if b is longer than a."]
    #[doc = ""]
    #[doc = " @param      a     First input and where output is written"]
    #[doc = " @param[in]  b     second input"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_subtract_inplace(a: *mut rc_vector_t, b: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates the dth derivative of the polynomial a and places the"]
    #[doc = " result in vector b."]
    #[doc = ""]
    #[doc = " @param[in]  a     Input polynomial coefficients"]
    #[doc = " @param[in]  d     which derivative to take (>=0)"]
    #[doc = " @param[out] b     result"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_differentiate(
        a: rc_vector_t,
        d: ::std::os::raw::c_int,
        b: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Divides denominator d into numerator n. The remainder is placed"]
    #[doc = " into vector rem and the divisor is placed into vector div."]
    #[doc = ""]
    #[doc = " @param[in]  n     numerator"]
    #[doc = " @param[in]  d     denominator"]
    #[doc = " @param      div   The resulting divisor"]
    #[doc = " @param      rem   The resulting remainder"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_divide(
        n: rc_vector_t,
        d: rc_vector_t,
        div: *mut rc_vector_t,
        rem: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates coefficients for continuous-time Butterworth"]
    #[doc = " polynomial of order N and cutoff wc (rad/s) and places them in vector b."]
    #[doc = ""]
    #[doc = " @param[in]  N     Order of the polynomial"]
    #[doc = " @param[in]  wc    cutoff frequency in rad/s"]
    #[doc = " @param[out] b     resulting coefficients"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success and -1 on failure."]
    pub fn rc_poly_butter(
        N: ::std::os::raw::c_int,
        wc: f64,
        b: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Returns the length of a quaternion vector by finding its 2-norm."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion in form of a vector of length 4"]
    #[doc = ""]
    #[doc = " @return     Returns the norm, or prints an error message and returns -1.0f on"]
    #[doc = " error."]
    pub fn rc_quaternion_norm(q: rc_vector_t) -> f64;
}
extern "C" {
    #[doc = " @brief      Returns the length of a quaternion vector by finding its 2-norm."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion in form of an array of length 4"]
    #[doc = ""]
    #[doc = " @return     Returns the norm, or prints an error message and returns -1.0f on"]
    #[doc = " error."]
    pub fn rc_quaternion_norm_array(q: *mut f64) -> f64;
}
extern "C" {
    #[doc = " @brief      Normalizes a quaternion in-place to have length 1.0"]
    #[doc = ""]
    #[doc = " @param      q     The quarternion in form of a vector of lenth 4"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_normalize_quaternion(q: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Normalizes a quaternion in-place to have length 1.0"]
    #[doc = ""]
    #[doc = " @param      q     The quarternion in form of an array of length 4"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_normalize_quaternion_array(q: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates 321 Tait Bryan angles in array order XYZ with"]
    #[doc = " operation order 321(yaw-Z, pitch-Y, roll-x)."]
    #[doc = ""]
    #[doc = " If tb is already allocated and of length 3 then the new values are written in"]
    #[doc = " place, otherwise any existing memory is freed and a new vector of length 3 is"]
    #[doc = " allocated for tb."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion in form of a vector of lenth 4"]
    #[doc = " @param      tb    Output tait-bryan angles"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_quaternion_to_tb(q: rc_vector_t, tb: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates 321 Tait Bryan angles in array order XYZ with"]
    #[doc = " operation order 321(yaw-Z, pitch-Y, roll-x)."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion in form of an array of lenth 4"]
    #[doc = " @param[out] tb    Output tait-bryan angles"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_quaternion_to_tb_array(q: *mut f64, tb: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates quaternion vector q from tait-bryan angles tb."]
    #[doc = ""]
    #[doc = " If q is already of length 4 then old contents are simply overwritten."]
    #[doc = " Otherwise q'd existing memory is freed and new memory is allocated to aint"]
    #[doc = " memory leaks. tb angles are 321 Tait Bryan angles in array order XYZ with"]
    #[doc = " operation order 321(yaw-Z, pitch-Y, roll-x)."]
    #[doc = ""]
    #[doc = " @param[in]  tb    input tait-bryan angles"]
    #[doc = " @param[out] q     output quaternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_quaternion_from_tb(tb: rc_vector_t, q: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates quaternion vector q from tait-bryan angles tb."]
    #[doc = ""]
    #[doc = " tb angles are 321 Tait Bryan angles in array order XYZ with operation order"]
    #[doc = " 321(yaw-Z, pitch-Y, roll-x)."]
    #[doc = ""]
    #[doc = " @param[in]  tb    input tait-bryan angles"]
    #[doc = " @param[out] q     output quaternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure"]
    pub fn rc_quaternion_from_tb_array(tb: *mut f64, q: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates conjugate of quaternion q."]
    #[doc = ""]
    #[doc = " Populates quaternion vector c with the conjugate of quaternion q where the 3"]
    #[doc = " imaginary parts ijk are multiplied by -1. If c is already of length 4 then"]
    #[doc = " the old values are overwritten. Otherwise the old memory in c is freed and"]
    #[doc = " new memory is allocated to help prevent memory leaks."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarter"]
    #[doc = " @param[out] c     output conjugate"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_conjugate(q: rc_vector_t, c: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates conjugate of quaternion q and overwrites the old q."]
    #[doc = ""]
    #[doc = " Populates quaternion vector q with its conjugate where the 3 imaginary parts"]
    #[doc = " ijk are multiplied by -1."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_conjugate_inplace(q: *mut rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates conjugate of quaternion q."]
    #[doc = ""]
    #[doc = " Populates quaternion vector c with the conjugate of quaternion q where the 3"]
    #[doc = " imaginary parts ijk are multiplied by -1."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarter"]
    #[doc = " @param[out] c     output conjugate"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_conjugate_array(q: *mut f64, c: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates conjugate of quaternion q and overwrites the old q."]
    #[doc = ""]
    #[doc = " Populates quaternion vector q with its conjugate where the 3 imaginary parts"]
    #[doc = " ijk are multiplied by -1."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_conjugate_array_inplace(q: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Populates vector i with the imaginary components ijk of of"]
    #[doc = " quaternion vector q."]
    #[doc = ""]
    #[doc = " If img is already of length 3 then its original contents are overwritten."]
    #[doc = " Otherwise the original allocated memory is freed and new memory is allocated."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarternion"]
    #[doc = " @param[out] img   imaginary part"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_imaginary_part(
        q: rc_vector_t,
        img: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates the quaternion Hamilton product ab=c"]
    #[doc = ""]
    #[doc = " Places the result in vector argument c. If c is already of length 4 then the"]
    #[doc = " old values are overwritten. Otherwise the old memory in c is freed and new"]
    #[doc = " memory is allocated to help prevent memory leaks."]
    #[doc = ""]
    #[doc = " @param[in]  a     First input"]
    #[doc = " @param[in]  b     second input"]
    #[doc = " @param[out] c     output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_multiply(
        a: rc_vector_t,
        b: rc_vector_t,
        c: *mut rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Calculates the quaternion Hamilton product ab=c"]
    #[doc = ""]
    #[doc = " Places the result in vector argument c."]
    #[doc = ""]
    #[doc = " @param[in]  a     First input"]
    #[doc = " @param[in]  b     second input"]
    #[doc = " @param[out] c     output"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_multiply_array(
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Rotates the quaternion p by quaternion q with the operation"]
    #[doc = " p'=qpq*"]
    #[doc = ""]
    #[doc = " p is modified in place, q is unmodified."]
    #[doc = ""]
    #[doc = " @param      p     quaternion to be rotated"]
    #[doc = " @param[in]  q     rotation quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_rotate(p: *mut rc_vector_t, q: rc_vector_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Rotates the quaternion p by quaternion q with the operation"]
    #[doc = " p'=qpq*"]
    #[doc = ""]
    #[doc = " p is modified in place, q is unmodified."]
    #[doc = ""]
    #[doc = " @param      p     quaternion to be rotated"]
    #[doc = " @param[in]  q     rotation quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_rotate_array(p: *mut f64, q: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Rotate a 3D vector v in-place about the origin by quaternion q by"]
    #[doc = " converting v to a quaternion and performing the operation p'=qpq*"]
    #[doc = ""]
    #[doc = " v is modified in place, q is unmodified."]
    #[doc = ""]
    #[doc = " @param      v     vectpr to be rotated"]
    #[doc = " @param[in]  q     rotation quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_rotate_vector(
        v: *mut rc_vector_t,
        q: rc_vector_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Rotate a 3D vector v in-place about the origin by quaternion q by"]
    #[doc = " converting v to a quaternion and performing the operation p'=qpq*"]
    #[doc = ""]
    #[doc = " v is modified in place, q is unmodified."]
    #[doc = ""]
    #[doc = " @param      v     vectpr to be rotated"]
    #[doc = " @param[in]  q     rotation quarternion"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_rotate_vector_array(v: *mut f64, q: *mut f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Converts a normalized quaternion to a 3x3 orthogonal rotation"]
    #[doc = " matrix."]
    #[doc = ""]
    #[doc = " q must be normalized before calling this! The orthogonal matrix corresponds"]
    #[doc = " to a rotation by the unit quaternion q when post-multiplied with a column"]
    #[doc = " vector as such: v_rotated=mv."]
    #[doc = ""]
    #[doc = " If m is already 3x3 then its contents are overwritten, otherwise its existing"]
    #[doc = " memory is freed and new memory is allocated."]
    #[doc = ""]
    #[doc = " @param[in]  q     The quarter"]
    #[doc = " @param      m     output 3x3 rotation matrix"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_quaternion_to_rotation_matrix(
        q: rc_vector_t,
        m: *mut rc_matrix_t,
    ) -> ::std::os::raw::c_int;
}
pub const rc_model_t_MODEL_UNKNOWN: rc_model_t = 0;
pub const rc_model_t_MODEL_BB_BLACK: rc_model_t = 1;
pub const rc_model_t_MODEL_BB_BLACK_RC: rc_model_t = 2;
pub const rc_model_t_MODEL_BB_BLACK_W: rc_model_t = 3;
pub const rc_model_t_MODEL_BB_BLACK_W_RC: rc_model_t = 4;
pub const rc_model_t_MODEL_BB_GREEN: rc_model_t = 5;
pub const rc_model_t_MODEL_BB_GREEN_W: rc_model_t = 6;
pub const rc_model_t_MODEL_BB_BLUE: rc_model_t = 7;
pub const rc_model_t_MODEL_RPI_B: rc_model_t = 8;
pub const rc_model_t_MODEL_RPI_B_PLUS: rc_model_t = 9;
pub const rc_model_t_MODEL_RPI2_B: rc_model_t = 10;
pub const rc_model_t_MODEL_RPI3_B: rc_model_t = 11;
pub const rc_model_t_MODEL_RPI3_B_PLUS: rc_model_t = 12;
pub const rc_model_t_MODEL_RPI0: rc_model_t = 13;
pub const rc_model_t_MODEL_RPI0_W: rc_model_t = 14;
pub const rc_model_t_MODEL_RPI_CM: rc_model_t = 15;
pub const rc_model_t_MODEL_RPI_CM3: rc_model_t = 16;
pub const rc_model_t_MODEL_PC: rc_model_t = 17;
#[doc = " List of models detectable by the rc_model() function. This is not a complete"]
#[doc = " list of board this library will run on. Nor is it a list of boards that the"]
#[doc = " library is guaranteed to work on. Currently, MODEL_PC indicates personal"]
#[doc = " computer and will be selected whenever running on an x86 or x86_64"]
#[doc = " architecture machine until more specific boards are added to this list by"]
#[doc = " user request."]
pub type rc_model_t = u32;
pub const rc_model_category_t_CATEGORY_UNKNOWN: rc_model_category_t = 0;
pub const rc_model_category_t_CATEGORY_BEAGLEBONE: rc_model_category_t = 1;
pub const rc_model_category_t_CATEGORY_RPI: rc_model_category_t = 2;
pub const rc_model_category_t_CATEGORY_PC: rc_model_category_t = 3;
#[doc = " This is a list of general categories of boards."]
pub type rc_model_category_t = u32;
extern "C" {
    #[doc = " @brief      gets the current board model name"]
    #[doc = ""]
    #[doc = " @return     rc_model_t enum representation of model"]
    pub fn rc_model() -> rc_model_t;
}
extern "C" {
    #[doc = " @brief      gets the general category for the current board"]
    #[doc = ""]
    #[doc = " @return     rc_model_category_t enum representation of categoy"]
    pub fn rc_model_category() -> rc_model_category_t;
}
extern "C" {
    #[doc = " @brief      prints to the screen the human-readable version of the model name"]
    #[doc = " with no trailing newline character."]
    pub fn rc_model_print();
}
extern "C" {
    #[doc = " @brief      prints to the screen the human-readable version of the category"]
    #[doc = " name with no trailing newline character."]
    pub fn rc_model_category_print();
}
extern "C" {
    #[doc = " @brief      Initializes all 4 motors and leaves them in a free-spin (0"]
    #[doc = " throttle) state."]
    #[doc = ""]
    #[doc = " Note, if the user is optionally using the rc_motor_standby functionality they"]
    #[doc = " should be aware that rc_motor_init starts standby mode in a disabled state so"]
    #[doc = " it is not necessary for the majority of users who are not interested in"]
    #[doc = " standby mode."]
    #[doc = ""]
    #[doc = " This starts the motor drivers at RC_MOTOR_DEFAULT_PWM_FREQ. To use another"]
    #[doc = " frequency initialize with rc_motor_init_freq instead."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure which is usually due to lack of user"]
    #[doc = " permissions to access the gpio and pwm systems."]
    pub fn rc_motor_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Just like rc_motor_init but allows the user to set the pwm"]
    #[doc = " frequency"]
    #[doc = ""]
    #[doc = " RC_MOTOR_DEFAULT_PWM_FREQ is a good frequency to start at."]
    #[doc = ""]
    #[doc = " Note, if the user is optionally using the rc_motor_standby functionality they"]
    #[doc = " should be aware that rc_motor_init starts standby mode in a disabled state so"]
    #[doc = " it is not necessary for the majority of users who are not interested in"]
    #[doc = " standby mode."]
    #[doc = ""]
    #[doc = " @param[in]  pwm_frequency_hz  The pwm frequency in hz"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure which is usually due to lack of user"]
    #[doc = " permissions to access the gpio and pwm systems."]
    pub fn rc_motor_init_freq(pwm_frequency_hz: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Puts all 4 motors into a free-spin (0 throttle) state, puts the"]
    #[doc = " h-bridges into standby mode, and closes all file pointers to GPIO and PWM"]
    #[doc = " systems."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_motor_cleanup() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Toggle the H-bridges in and out of low-power standby mode."]
    #[doc = ""]
    #[doc = " This is an entirely optional function as calling rc_motor_cleanup when your"]
    #[doc = " program closes will put the h-bridges into standby mode and then calling"]
    #[doc = " rc_motor_init at the beginning of your program will take them out of standby"]
    #[doc = " mode. However, if the user wishes to toggle in and out of standby mode in"]
    #[doc = " their program (for example while paused) then they can use this function."]
    #[doc = ""]
    #[doc = " @param[in]  standby_en  1 to enable standby mode, 0 to disable"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_motor_standby(standby_en: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the bidirectional duty cycle (power) to a single motor or"]
    #[doc = " all motors if 0 is provided as a channel."]
    #[doc = ""]
    #[doc = " @param[in]  ch    The motor channel (1-4) or 0 for all channels."]
    #[doc = " @param[in]  duty  Duty cycle, -1.0 for full reverse, 1.0 for full forward"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_motor_set(ch: ::std::os::raw::c_int, duty: f64) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Puts a motor into a zero-throttle state allowing it to spin"]
    #[doc = " freely."]
    #[doc = ""]
    #[doc = " This is accomplished by putting both motor terminals connected to the"]
    #[doc = " h-bridge into a high-impedance state."]
    #[doc = ""]
    #[doc = " @param[in]  ch    The motor channel (1-4) or 0 for all channels."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_motor_free_spin(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Connects the motor terminal pairs together which makes the motor"]
    #[doc = " fight against its own back EMF turning it into a brake resisting rotation."]
    #[doc = ""]
    #[doc = " @param[in]  ch    The motor channel (1-4) or 0 for all channels."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_motor_brake(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __quad_t = ::std::os::raw::c_longlong;
pub type __u_quad_t = ::std::os::raw::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = __quad_t;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_int;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type time_t = __time_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        8usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        4usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type pid_t = __pid_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_sched_param() {
    assert_eq!(
        ::std::mem::size_of::<sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sched_param {
    pub __sched_priority: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___sched_param() {
    assert_eq!(
        ::std::mem::size_of::<__sched_param>(),
        4usize,
        concat!("Size of: ", stringify!(__sched_param))
    );
    assert_eq!(
        ::std::mem::align_of::<__sched_param>(),
        4usize,
        concat!("Alignment of ", stringify!(__sched_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sched_param>())).__sched_priority as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sched_param),
            "::",
            stringify!(__sched_priority)
        )
    );
}
pub type __cpu_mask = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cpu_set_t {
    pub __bits: [__cpu_mask; 32usize],
}
#[test]
fn bindgen_test_layout_cpu_set_t() {
    assert_eq!(
        ::std::mem::size_of::<cpu_set_t>(),
        128usize,
        concat!("Size of: ", stringify!(cpu_set_t))
    );
    assert_eq!(
        ::std::mem::align_of::<cpu_set_t>(),
        4usize,
        concat!("Alignment of ", stringify!(cpu_set_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<cpu_set_t>())).__bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(cpu_set_t),
            "::",
            stringify!(__bits)
        )
    );
}
extern "C" {
    pub fn __sched_cpucount(__setsize: usize, __setp: *const cpu_set_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __sched_cpualloc(__count: usize) -> *mut cpu_set_t;
}
extern "C" {
    pub fn __sched_cpufree(__set: *mut cpu_set_t);
}
extern "C" {
    pub fn sched_setparam(__pid: __pid_t, __param: *const sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getparam(__pid: __pid_t, __param: *mut sched_param) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_setscheduler(
        __pid: __pid_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_getscheduler(__pid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_yield() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_max(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_get_priority_min(__algorithm: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sched_rr_get_interval(__pid: __pid_t, __t: *mut timespec) -> ::std::os::raw::c_int;
}
pub type clock_t = __clock_t;
pub type clockid_t = __clockid_t;
pub type timer_t = __timer_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    pub tm_sec: ::std::os::raw::c_int,
    pub tm_min: ::std::os::raw::c_int,
    pub tm_hour: ::std::os::raw::c_int,
    pub tm_mday: ::std::os::raw::c_int,
    pub tm_mon: ::std::os::raw::c_int,
    pub tm_year: ::std::os::raw::c_int,
    pub tm_wday: ::std::os::raw::c_int,
    pub tm_yday: ::std::os::raw::c_int,
    pub tm_isdst: ::std::os::raw::c_int,
    pub tm_gmtoff: ::std::os::raw::c_long,
    pub tm_zone: *const ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_tm() {
    assert_eq!(
        ::std::mem::size_of::<tm>(),
        44usize,
        concat!("Size of: ", stringify!(tm))
    );
    assert_eq!(
        ::std::mem::align_of::<tm>(),
        4usize,
        concat!("Alignment of ", stringify!(tm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_min as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_hour as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_hour)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mday as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_mon as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_mon)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_year as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_year)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_wday as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_wday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_yday as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_yday)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_isdst as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_isdst)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_gmtoff as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_gmtoff)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<tm>())).tm_zone as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(tm),
            "::",
            stringify!(tm_zone)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerspec {
    pub it_interval: timespec,
    pub it_value: timespec,
}
#[test]
fn bindgen_test_layout_itimerspec() {
    assert_eq!(
        ::std::mem::size_of::<itimerspec>(),
        16usize,
        concat!("Size of: ", stringify!(itimerspec))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerspec>(),
        4usize,
        concat!("Alignment of ", stringify!(itimerspec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerspec>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerspec),
            "::",
            stringify!(it_value)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigevent {
    _unused: [u8; 0],
}
extern "C" {
    pub fn clock() -> clock_t;
}
extern "C" {
    pub fn time(__timer: *mut time_t) -> time_t;
}
extern "C" {
    pub fn difftime(__time1: time_t, __time0: time_t) -> f64;
}
extern "C" {
    pub fn mktime(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn strftime(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
    ) -> usize;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    pub __locales: [*mut __locale_data; 13usize],
    pub __ctype_b: *const ::std::os::raw::c_ushort,
    pub __ctype_tolower: *const ::std::os::raw::c_int,
    pub __ctype_toupper: *const ::std::os::raw::c_int,
    pub __names: [*const ::std::os::raw::c_char; 13usize],
}
#[test]
fn bindgen_test_layout___locale_struct() {
    assert_eq!(
        ::std::mem::size_of::<__locale_struct>(),
        116usize,
        concat!("Size of: ", stringify!(__locale_struct))
    );
    assert_eq!(
        ::std::mem::align_of::<__locale_struct>(),
        4usize,
        concat!("Alignment of ", stringify!(__locale_struct))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__locales as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__locales)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_b as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_tolower as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_tolower)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__ctype_toupper as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__ctype_toupper)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__locale_struct>())).__names as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__locale_struct),
            "::",
            stringify!(__names)
        )
    );
}
pub type __locale_t = *mut __locale_struct;
pub type locale_t = __locale_t;
extern "C" {
    pub fn strftime_l(
        __s: *mut ::std::os::raw::c_char,
        __maxsize: usize,
        __format: *const ::std::os::raw::c_char,
        __tp: *const tm,
        __loc: __locale_t,
    ) -> usize;
}
extern "C" {
    pub fn gmtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn localtime(__timer: *const time_t) -> *mut tm;
}
extern "C" {
    pub fn gmtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn localtime_r(__timer: *const time_t, __tp: *mut tm) -> *mut tm;
}
extern "C" {
    pub fn asctime(__tp: *const tm) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime(__timer: *const time_t) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn asctime_r(
        __tp: *const tm,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ctime_r(
        __timer: *const time_t,
        __buf: *mut ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub static mut __tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub static mut __daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut __timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub static mut tzname: [*mut ::std::os::raw::c_char; 2usize];
}
extern "C" {
    pub fn tzset();
}
extern "C" {
    pub static mut daylight: ::std::os::raw::c_int;
}
extern "C" {
    pub static mut timezone: ::std::os::raw::c_long;
}
extern "C" {
    pub fn stime(__when: *const time_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timegm(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn timelocal(__tp: *mut tm) -> time_t;
}
extern "C" {
    pub fn dysize(__year: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nanosleep(
        __requested_time: *const timespec,
        __remaining: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getres(__clock_id: clockid_t, __res: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_gettime(__clock_id: clockid_t, __tp: *mut timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_settime(__clock_id: clockid_t, __tp: *const timespec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_nanosleep(
        __clock_id: clockid_t,
        __flags: ::std::os::raw::c_int,
        __req: *const timespec,
        __rem: *mut timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clock_getcpuclockid(__pid: pid_t, __clock_id: *mut clockid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_create(
        __clock_id: clockid_t,
        __evp: *mut sigevent,
        __timerid: *mut timer_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_delete(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_settime(
        __timerid: timer_t,
        __flags: ::std::os::raw::c_int,
        __value: *const itimerspec,
        __ovalue: *mut itimerspec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_gettime(__timerid: timer_t, __value: *mut itimerspec) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timer_getoverrun(__timerid: timer_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn timespec_get(
        __ts: *mut timespec,
        __base: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
pub type pthread_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_attr_t {
    pub __size: [::std::os::raw::c_char; 36usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 9usize],
}
#[test]
fn bindgen_test_layout_pthread_attr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_attr_t>(),
        36usize,
        concat!("Size of: ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_attr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_attr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_attr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_attr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_slist {
    pub __next: *mut __pthread_internal_slist,
}
#[test]
fn bindgen_test_layout___pthread_internal_slist() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Size of: ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_slist>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_internal_slist))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_slist>())).__next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_slist),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_slist_t = __pthread_internal_slist;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: pthread_mutex_t___pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 24usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 6usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct pthread_mutex_t___pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __kind: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: pthread_mutex_t___pthread_mutex_s__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t___pthread_mutex_s__bindgen_ty_1 {
    pub __spins: ::std::os::raw::c_int,
    pub __list: __pthread_slist_t,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>())).__spins
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s__bindgen_ty_1>())).__list
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s__bindgen_ty_1),
            "::",
            stringify!(__list)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t___pthread_mutex_s>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t___pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t___pthread_mutex_s>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(pthread_mutex_t___pthread_mutex_s)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__lock as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__count as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__owner as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__kind as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_mutex_t___pthread_mutex_s>())).__nusers as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t___pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        24usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutexattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_mutexattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutexattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutexattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutexattr_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: pthread_cond_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_cond_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __futex: ::std::os::raw::c_uint,
    pub __total_seq: ::std::os::raw::c_ulonglong,
    pub __wakeup_seq: ::std::os::raw::c_ulonglong,
    pub __woken_seq: ::std::os::raw::c_ulonglong,
    pub __mutex: *mut ::std::os::raw::c_void,
    pub __nwaiters: ::std::os::raw::c_uint,
    pub __broadcast_seq: ::std::os::raw::c_uint,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_pthread_cond_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__futex as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__futex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__total_seq as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__total_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__wakeup_seq as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__wakeup_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__woken_seq as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__woken_seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__mutex as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__mutex)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__nwaiters as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__nwaiters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_cond_t__bindgen_ty_1>())).__broadcast_seq as *const _
                as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t__bindgen_ty_1),
            "::",
            stringify!(__broadcast_seq)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_condattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_condattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_condattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_condattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_condattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_condattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_condattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_key_t = ::std::os::raw::c_uint;
pub type pthread_once_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlock_t {
    pub __data: pthread_rwlock_t__bindgen_ty_1,
    pub __size: [::std::os::raw::c_char; 32usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 8usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct pthread_rwlock_t__bindgen_ty_1 {
    pub __lock: ::std::os::raw::c_int,
    pub __nr_readers: ::std::os::raw::c_uint,
    pub __readers_wakeup: ::std::os::raw::c_uint,
    pub __writer_wakeup: ::std::os::raw::c_uint,
    pub __nr_readers_queued: ::std::os::raw::c_uint,
    pub __nr_writers_queued: ::std::os::raw::c_uint,
    pub __flags: ::std::os::raw::c_uchar,
    pub __shared: ::std::os::raw::c_uchar,
    pub __pad1: ::std::os::raw::c_uchar,
    pub __pad2: ::std::os::raw::c_uchar,
    pub __writer: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t__bindgen_ty_1>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__lock as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__readers_wakeup as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__readers_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer_wakeup as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer_wakeup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_readers_queued
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_readers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__nr_writers_queued
                as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__nr_writers_queued)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__shared as *const _ as usize
        },
        25usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__shared)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad1 as *const _ as usize
        },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__pad2 as *const _ as usize
        },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<pthread_rwlock_t__bindgen_ty_1>())).__writer as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t__bindgen_ty_1),
            "::",
            stringify!(__writer)
        )
    );
}
#[test]
fn bindgen_test_layout_pthread_rwlock_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlock_t>(),
        32usize,
        concat!("Size of: ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlock_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlock_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlock_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_rwlockattr_t {
    pub __size: [::std::os::raw::c_char; 8usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 2usize],
}
#[test]
fn bindgen_test_layout_pthread_rwlockattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_rwlockattr_t>(),
        8usize,
        concat!("Size of: ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_rwlockattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_rwlockattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_rwlockattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type pthread_spinlock_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrier_t {
    pub __size: [::std::os::raw::c_char; 20usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u32; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_barrier_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrier_t>(),
        20usize,
        concat!("Size of: ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrier_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrier_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrier_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrier_t),
            "::",
            stringify!(__align)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_barrierattr_t {
    pub __size: [::std::os::raw::c_char; 4usize],
    pub __align: ::std::os::raw::c_int,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_pthread_barrierattr_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Size of: ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_barrierattr_t>(),
        4usize,
        concat!("Alignment of ", stringify!(pthread_barrierattr_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_barrierattr_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_barrierattr_t),
            "::",
            stringify!(__align)
        )
    );
}
pub type __jmp_buf = [::std::os::raw::c_int; 64usize];
pub const PTHREAD_CREATE_JOINABLE: _bindgen_ty_1 = 0;
pub const PTHREAD_CREATE_DETACHED: _bindgen_ty_1 = 1;
pub type _bindgen_ty_1 = u32;
pub const PTHREAD_MUTEX_TIMED_NP: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE_NP: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK_NP: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_ADAPTIVE_NP: _bindgen_ty_2 = 3;
pub const PTHREAD_MUTEX_NORMAL: _bindgen_ty_2 = 0;
pub const PTHREAD_MUTEX_RECURSIVE: _bindgen_ty_2 = 1;
pub const PTHREAD_MUTEX_ERRORCHECK: _bindgen_ty_2 = 2;
pub const PTHREAD_MUTEX_DEFAULT: _bindgen_ty_2 = 0;
pub type _bindgen_ty_2 = u32;
pub const PTHREAD_MUTEX_STALLED: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_STALLED_NP: _bindgen_ty_3 = 0;
pub const PTHREAD_MUTEX_ROBUST: _bindgen_ty_3 = 1;
pub const PTHREAD_MUTEX_ROBUST_NP: _bindgen_ty_3 = 1;
pub type _bindgen_ty_3 = u32;
pub const PTHREAD_PRIO_NONE: _bindgen_ty_4 = 0;
pub const PTHREAD_PRIO_INHERIT: _bindgen_ty_4 = 1;
pub const PTHREAD_PRIO_PROTECT: _bindgen_ty_4 = 2;
pub type _bindgen_ty_4 = u32;
pub const PTHREAD_RWLOCK_PREFER_READER_NP: _bindgen_ty_5 = 0;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NP: _bindgen_ty_5 = 1;
pub const PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP: _bindgen_ty_5 = 2;
pub const PTHREAD_RWLOCK_DEFAULT_NP: _bindgen_ty_5 = 0;
pub type _bindgen_ty_5 = u32;
pub const PTHREAD_INHERIT_SCHED: _bindgen_ty_6 = 0;
pub const PTHREAD_EXPLICIT_SCHED: _bindgen_ty_6 = 1;
pub type _bindgen_ty_6 = u32;
pub const PTHREAD_SCOPE_SYSTEM: _bindgen_ty_7 = 0;
pub const PTHREAD_SCOPE_PROCESS: _bindgen_ty_7 = 1;
pub type _bindgen_ty_7 = u32;
pub const PTHREAD_PROCESS_PRIVATE: _bindgen_ty_8 = 0;
pub const PTHREAD_PROCESS_SHARED: _bindgen_ty_8 = 1;
pub type _bindgen_ty_8 = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _pthread_cleanup_buffer {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __canceltype: ::std::os::raw::c_int,
    pub __prev: *mut _pthread_cleanup_buffer,
}
#[test]
fn bindgen_test_layout__pthread_cleanup_buffer() {
    assert_eq!(
        ::std::mem::size_of::<_pthread_cleanup_buffer>(),
        16usize,
        concat!("Size of: ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        ::std::mem::align_of::<_pthread_cleanup_buffer>(),
        4usize,
        concat!("Alignment of ", stringify!(_pthread_cleanup_buffer))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__routine as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__arg as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__canceltype as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__canceltype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_pthread_cleanup_buffer>())).__prev as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_pthread_cleanup_buffer),
            "::",
            stringify!(__prev)
        )
    );
}
pub const PTHREAD_CANCEL_ENABLE: _bindgen_ty_9 = 0;
pub const PTHREAD_CANCEL_DISABLE: _bindgen_ty_9 = 1;
pub type _bindgen_ty_9 = u32;
pub const PTHREAD_CANCEL_DEFERRED: _bindgen_ty_10 = 0;
pub const PTHREAD_CANCEL_ASYNCHRONOUS: _bindgen_ty_10 = 1;
pub type _bindgen_ty_10 = u32;
extern "C" {
    pub fn pthread_create(
        __newthread: *mut pthread_t,
        __attr: *const pthread_attr_t,
        __start_routine: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        __arg: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_exit(__retval: *mut ::std::os::raw::c_void);
}
extern "C" {
    pub fn pthread_join(
        __th: pthread_t,
        __thread_return: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_detach(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_self() -> pthread_t;
}
extern "C" {
    pub fn pthread_equal(__thread1: pthread_t, __thread2: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_init(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_destroy(__attr: *mut pthread_attr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getdetachstate(
        __attr: *const pthread_attr_t,
        __detachstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setdetachstate(
        __attr: *mut pthread_attr_t,
        __detachstate: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getguardsize(
        __attr: *const pthread_attr_t,
        __guardsize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setguardsize(
        __attr: *mut pthread_attr_t,
        __guardsize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedparam(
        __attr: *const pthread_attr_t,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedparam(
        __attr: *mut pthread_attr_t,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getschedpolicy(
        __attr: *const pthread_attr_t,
        __policy: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setschedpolicy(
        __attr: *mut pthread_attr_t,
        __policy: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getinheritsched(
        __attr: *const pthread_attr_t,
        __inherit: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setinheritsched(
        __attr: *mut pthread_attr_t,
        __inherit: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getscope(
        __attr: *const pthread_attr_t,
        __scope: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setscope(
        __attr: *mut pthread_attr_t,
        __scope: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstackaddr(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstackaddr(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstacksize(
        __attr: *const pthread_attr_t,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstacksize(
        __attr: *mut pthread_attr_t,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_getstack(
        __attr: *const pthread_attr_t,
        __stackaddr: *mut *mut ::std::os::raw::c_void,
        __stacksize: *mut usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_attr_setstack(
        __attr: *mut pthread_attr_t,
        __stackaddr: *mut ::std::os::raw::c_void,
        __stacksize: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedparam(
        __target_thread: pthread_t,
        __policy: ::std::os::raw::c_int,
        __param: *const sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getschedparam(
        __target_thread: pthread_t,
        __policy: *mut ::std::os::raw::c_int,
        __param: *mut sched_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setschedprio(
        __target_thread: pthread_t,
        __prio: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_once(
        __once_control: *mut pthread_once_t,
        __init_routine: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcancelstate(
        __state: ::std::os::raw::c_int,
        __oldstate: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_setcanceltype(
        __type: ::std::os::raw::c_int,
        __oldtype: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cancel(__th: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_testcancel();
}
#[repr(C)]
#[repr(align(8))]
#[derive(Copy, Clone)]
pub struct __pthread_unwind_buf_t {
    pub __cancel_jmp_buf: [__pthread_unwind_buf_t__bindgen_ty_1; 1usize],
    pub __pad: [*mut ::std::os::raw::c_void; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_unwind_buf_t__bindgen_ty_1 {
    pub __cancel_jmp_buf: __jmp_buf,
    pub __mask_was_saved: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        264usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__cancel_jmp_buf
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t__bindgen_ty_1>())).__mask_was_saved
                as *const _ as usize
        },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t__bindgen_ty_1),
            "::",
            stringify!(__mask_was_saved)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_unwind_buf_t() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_unwind_buf_t>(),
        280usize,
        concat!("Size of: ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_unwind_buf_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_unwind_buf_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__cancel_jmp_buf as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__cancel_jmp_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_unwind_buf_t>())).__pad as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_unwind_buf_t),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_cleanup_frame {
    pub __cancel_routine:
        ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __cancel_arg: *mut ::std::os::raw::c_void,
    pub __do_it: ::std::os::raw::c_int,
    pub __cancel_type: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout___pthread_cleanup_frame() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cleanup_frame>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cleanup_frame>(),
        4usize,
        concat!("Alignment of ", stringify!(__pthread_cleanup_frame))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_routine as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_routine)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_arg as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_arg)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__do_it as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__do_it)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cleanup_frame>())).__cancel_type as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cleanup_frame),
            "::",
            stringify!(__cancel_type)
        )
    );
}
extern "C" {
    pub fn __pthread_register_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unregister_cancel(__buf: *mut __pthread_unwind_buf_t);
}
extern "C" {
    pub fn __pthread_unwind_next(__buf: *mut __pthread_unwind_buf_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __jmp_buf_tag {
    _unused: [u8; 0],
}
extern "C" {
    pub fn __sigsetjmp(
        __env: *mut __jmp_buf_tag,
        __savemask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_init(
        __mutex: *mut pthread_mutex_t,
        __mutexattr: *const pthread_mutexattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_destroy(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_trylock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_lock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_timedlock(
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_unlock(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_getprioceiling(
        __mutex: *const pthread_mutex_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_setprioceiling(
        __mutex: *mut pthread_mutex_t,
        __prioceiling: ::std::os::raw::c_int,
        __old_ceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutex_consistent(__mutex: *mut pthread_mutex_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_init(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_destroy(__attr: *mut pthread_mutexattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getpshared(
        __attr: *const pthread_mutexattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setpshared(
        __attr: *mut pthread_mutexattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_gettype(
        __attr: *const pthread_mutexattr_t,
        __kind: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_settype(
        __attr: *mut pthread_mutexattr_t,
        __kind: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprotocol(
        __attr: *const pthread_mutexattr_t,
        __protocol: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprotocol(
        __attr: *mut pthread_mutexattr_t,
        __protocol: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getprioceiling(
        __attr: *const pthread_mutexattr_t,
        __prioceiling: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setprioceiling(
        __attr: *mut pthread_mutexattr_t,
        __prioceiling: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_getrobust(
        __attr: *const pthread_mutexattr_t,
        __robustness: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_mutexattr_setrobust(
        __attr: *mut pthread_mutexattr_t,
        __robustness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_init(
        __rwlock: *mut pthread_rwlock_t,
        __attr: *const pthread_rwlockattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_destroy(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_rdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_tryrdlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedrdlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_wrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_trywrlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_timedwrlock(
        __rwlock: *mut pthread_rwlock_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlock_unlock(__rwlock: *mut pthread_rwlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_init(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_destroy(__attr: *mut pthread_rwlockattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getpshared(
        __attr: *const pthread_rwlockattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setpshared(
        __attr: *mut pthread_rwlockattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_getkind_np(
        __attr: *const pthread_rwlockattr_t,
        __pref: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_rwlockattr_setkind_np(
        __attr: *mut pthread_rwlockattr_t,
        __pref: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_init(
        __cond: *mut pthread_cond_t,
        __cond_attr: *const pthread_condattr_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_destroy(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_signal(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_broadcast(__cond: *mut pthread_cond_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_wait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_cond_timedwait(
        __cond: *mut pthread_cond_t,
        __mutex: *mut pthread_mutex_t,
        __abstime: *const timespec,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_init(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_destroy(__attr: *mut pthread_condattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getpshared(
        __attr: *const pthread_condattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setpshared(
        __attr: *mut pthread_condattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_getclock(
        __attr: *const pthread_condattr_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_condattr_setclock(
        __attr: *mut pthread_condattr_t,
        __clock_id: __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_init(
        __lock: *mut pthread_spinlock_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_destroy(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_lock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_trylock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_spin_unlock(__lock: *mut pthread_spinlock_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_init(
        __barrier: *mut pthread_barrier_t,
        __attr: *const pthread_barrierattr_t,
        __count: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_destroy(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrier_wait(__barrier: *mut pthread_barrier_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_init(__attr: *mut pthread_barrierattr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_destroy(__attr: *mut pthread_barrierattr_t)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_getpshared(
        __attr: *const pthread_barrierattr_t,
        __pshared: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_barrierattr_setpshared(
        __attr: *mut pthread_barrierattr_t,
        __pshared: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_create(
        __key: *mut pthread_key_t,
        __destr_function: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_key_delete(__key: pthread_key_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getspecific(__key: pthread_key_t) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn pthread_setspecific(
        __key: pthread_key_t,
        __pointer: *const ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_getcpuclockid(
        __thread_id: pthread_t,
        __clock_id: *mut __clockid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pthread_atfork(
        __prepare: ::std::option::Option<unsafe extern "C" fn()>,
        __parent: ::std::option::Option<unsafe extern "C" fn()>,
        __child: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
pub const rc_mpu_accel_fsr_t_ACCEL_FSR_2G: rc_mpu_accel_fsr_t = 0;
pub const rc_mpu_accel_fsr_t_ACCEL_FSR_4G: rc_mpu_accel_fsr_t = 1;
pub const rc_mpu_accel_fsr_t_ACCEL_FSR_8G: rc_mpu_accel_fsr_t = 2;
pub const rc_mpu_accel_fsr_t_ACCEL_FSR_16G: rc_mpu_accel_fsr_t = 3;
#[doc = " @brief      accelerometer full scale range options"]
#[doc = ""]
#[doc = " The user may choose from 4 full scale ranges of the accelerometer and"]
#[doc = " gyroscope. They have units of gravity (G) and degrees per second (DPS) The"]
#[doc = " defaults values are A_FSR_2G and G_FSR_2000DPS respectively."]
pub type rc_mpu_accel_fsr_t = u32;
pub const rc_mpu_gyro_fsr_t_GYRO_FSR_250DPS: rc_mpu_gyro_fsr_t = 0;
pub const rc_mpu_gyro_fsr_t_GYRO_FSR_500DPS: rc_mpu_gyro_fsr_t = 1;
pub const rc_mpu_gyro_fsr_t_GYRO_FSR_1000DPS: rc_mpu_gyro_fsr_t = 2;
pub const rc_mpu_gyro_fsr_t_GYRO_FSR_2000DPS: rc_mpu_gyro_fsr_t = 3;
#[doc = " @brief      gyroscope full scale range options"]
#[doc = ""]
#[doc = " The user may choose from 4 full scale ranges of the accelerometer and"]
#[doc = " gyroscope. They have units of gravity (G) and degrees per second (DPS) The"]
#[doc = " defaults values are A_FSR_2G and G_FSR_2000DPS respectively."]
pub type rc_mpu_gyro_fsr_t = u32;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_OFF: rc_mpu_accel_dlpf_t = 0;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_460: rc_mpu_accel_dlpf_t = 1;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_184: rc_mpu_accel_dlpf_t = 2;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_92: rc_mpu_accel_dlpf_t = 3;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_41: rc_mpu_accel_dlpf_t = 4;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_20: rc_mpu_accel_dlpf_t = 5;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_10: rc_mpu_accel_dlpf_t = 6;
pub const rc_mpu_accel_dlpf_t_ACCEL_DLPF_5: rc_mpu_accel_dlpf_t = 7;
#[doc = " @brief      accelerometer digital low-pass filter options"]
#[doc = ""]
#[doc = " The user may choose from 7 digital low pass filter constants for the"]
#[doc = " accelerometer and gyroscope. The filter runs at 1kz and helps to reduce"]
#[doc = " sensor noise when sampling more slowly. The default values are ACCEL_DLPF_184"]
#[doc = " GYRO_DLPF_184. Lower cut-off frequencies incur phase-loss in measurements."]
#[doc = " Number is cutoff frequency in hz."]
pub type rc_mpu_accel_dlpf_t = u32;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_OFF: rc_mpu_gyro_dlpf_t = 0;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_250: rc_mpu_gyro_dlpf_t = 1;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_184: rc_mpu_gyro_dlpf_t = 2;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_92: rc_mpu_gyro_dlpf_t = 3;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_41: rc_mpu_gyro_dlpf_t = 4;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_20: rc_mpu_gyro_dlpf_t = 5;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_10: rc_mpu_gyro_dlpf_t = 6;
pub const rc_mpu_gyro_dlpf_t_GYRO_DLPF_5: rc_mpu_gyro_dlpf_t = 7;
#[doc = " @brief      gyroscope digital low-pass filter options"]
#[doc = ""]
#[doc = " The user may choose from 7 digital low pass filter constants for the"]
#[doc = " accelerometer and gyroscope. The filter runs at 1kz and helps to reduce"]
#[doc = " sensor noise when sampling more slowly. The default values are ACCEL_DLPF_184"]
#[doc = " GYRO_DLPF_184. Lower cut-off frequencies incur phase-loss in measurements."]
#[doc = " Number is cutoff frequency in hz."]
pub type rc_mpu_gyro_dlpf_t = u32;
pub const rc_mpu_orientation_t_ORIENTATION_Z_UP: rc_mpu_orientation_t = 136;
pub const rc_mpu_orientation_t_ORIENTATION_Z_DOWN: rc_mpu_orientation_t = 396;
pub const rc_mpu_orientation_t_ORIENTATION_X_UP: rc_mpu_orientation_t = 14;
pub const rc_mpu_orientation_t_ORIENTATION_X_DOWN: rc_mpu_orientation_t = 266;
pub const rc_mpu_orientation_t_ORIENTATION_Y_UP: rc_mpu_orientation_t = 112;
pub const rc_mpu_orientation_t_ORIENTATION_Y_DOWN: rc_mpu_orientation_t = 336;
pub const rc_mpu_orientation_t_ORIENTATION_X_FORWARD: rc_mpu_orientation_t = 133;
pub const rc_mpu_orientation_t_ORIENTATION_X_BACK: rc_mpu_orientation_t = 161;
#[doc = " @brief      Orientation of the sensor."]
#[doc = ""]
#[doc = " This is only applicable when operating in DMP mode. This is the orientation"]
#[doc = " that the DMP consideres neutral, aka where roll/pitch/yaw are zero."]
pub type rc_mpu_orientation_t = u32;
#[doc = " @brief      configuration of the mpu sensor"]
#[doc = ""]
#[doc = " Configuration struct passed to rc_mpu_initialize and rc_mpu_initialize_dmp."]
#[doc = " It is best to get the default config with rc_mpu_default_config() function"]
#[doc = " first and modify from there."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_mpu_config_t {
    #[doc = "< gpio pin, default 3 on Robotics Cape and BB Blue"]
    pub gpio_interrupt_pin_chip: ::std::os::raw::c_int,
    #[doc = "< gpio pin, default 21 on Robotics Cape and BB Blue"]
    pub gpio_interrupt_pin: ::std::os::raw::c_int,
    #[doc = "< which bus to use, default 2 on Robotics Cape and BB Blue"]
    pub i2c_bus: ::std::os::raw::c_int,
    #[doc = "< default is 0x68, pull pin ad0 high to make it 0x69"]
    pub i2c_addr: u8,
    #[doc = "< set to 1 to print i2c_bus warnings for debug"]
    pub show_warnings: ::std::os::raw::c_int,
    #[doc = "< accelerometer full scale range, default ACCEL_FSR_8G"]
    pub accel_fsr: rc_mpu_accel_fsr_t,
    #[doc = "< gyroscope full scale range, default GYRO_FSR_2000DPS"]
    pub gyro_fsr: rc_mpu_gyro_fsr_t,
    #[doc = "< internal low pass filter cutoff, default ACCEL_DLPF_184"]
    pub accel_dlpf: rc_mpu_accel_dlpf_t,
    #[doc = "< internal low pass filter cutoff, default GYRO_DLPF_184"]
    pub gyro_dlpf: rc_mpu_gyro_dlpf_t,
    #[doc = "< magnetometer use is optional, set to 1 to enable, default 0 (off)"]
    pub enable_magnetometer: ::std::os::raw::c_int,
    #[doc = "< sample rate in hertz, 200,100,50,40,25,20,10,8,5,4"]
    pub dmp_sample_rate: ::std::os::raw::c_int,
    #[doc = "< set to 1 to optionally raw accel/gyro when reading DMP quaternion, default: 0 (off)"]
    pub dmp_fetch_accel_gyro: ::std::os::raw::c_int,
    #[doc = "< set to 1 to let DMP auto calibrate the gyro while in use, default: 0 (off)"]
    pub dmp_auto_calibrate_gyro: ::std::os::raw::c_int,
    #[doc = "< DMP orientation matrix, see rc_mpu_orientation_t"]
    pub orient: rc_mpu_orientation_t,
    #[doc = "< time constant (seconds) for filtering compass with gyroscope yaw value, default 25"]
    pub compass_time_constant: f64,
    #[doc = "< Scheduler policy for DMP interrupt handler and user callback, default SCHED_OTHER"]
    pub dmp_interrupt_sched_policy: ::std::os::raw::c_int,
    #[doc = "< scheduler priority for DMP interrupt handler and user callback, default 0"]
    pub dmp_interrupt_priority: ::std::os::raw::c_int,
    #[doc = "< reads magnetometer after DMP callback function to improve latency, default 1 (true)"]
    pub read_mag_after_callback: ::std::os::raw::c_int,
    #[doc = "< magnetometer_sample_rate = dmp_sample_rate/mag_sample_rate_div, default: 4"]
    pub mag_sample_rate_div: ::std::os::raw::c_int,
    #[doc = "< threshold impulse for triggering a tap in units of mg/ms"]
    pub tap_threshold: ::std::os::raw::c_int,
    pub __bindgen_padding_0: u32,
}
#[test]
fn bindgen_test_layout_rc_mpu_config_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_mpu_config_t>(),
        88usize,
        concat!("Size of: ", stringify!(rc_mpu_config_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_mpu_config_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rc_mpu_config_t))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).gpio_interrupt_pin_chip as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(gpio_interrupt_pin_chip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).gpio_interrupt_pin as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(gpio_interrupt_pin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).i2c_bus as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(i2c_bus)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).i2c_addr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(i2c_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).show_warnings as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(show_warnings)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).accel_fsr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(accel_fsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).gyro_fsr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(gyro_fsr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).accel_dlpf as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(accel_dlpf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).gyro_dlpf as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(gyro_dlpf)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).enable_magnetometer as *const _ as usize
        },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(enable_magnetometer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).dmp_sample_rate as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(dmp_sample_rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).dmp_fetch_accel_gyro as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(dmp_fetch_accel_gyro)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).dmp_auto_calibrate_gyro as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(dmp_auto_calibrate_gyro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).orient as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(orient)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).compass_time_constant as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(compass_time_constant)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).dmp_interrupt_sched_policy as *const _
                as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(dmp_interrupt_sched_policy)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).dmp_interrupt_priority as *const _ as usize
        },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(dmp_interrupt_priority)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).read_mag_after_callback as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(read_mag_after_callback)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_config_t>())).mag_sample_rate_div as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(mag_sample_rate_div)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_config_t>())).tap_threshold as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_config_t),
            "::",
            stringify!(tap_threshold)
        )
    );
}
#[doc = " @brief      data struct populated with new sensor data"]
#[doc = ""]
#[doc = " This is the container for holding the sensor data. The user is intended to"]
#[doc = " make their own instance of this struct and pass its pointer to imu read"]
#[doc = " functions. new data will then be written back into the user's instance of the"]
#[doc = " data struct."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rc_mpu_data_t {
    #[doc = "< accelerometer (XYZ) in units of m/s^2"]
    pub accel: [f64; 3usize],
    #[doc = "< gyroscope (XYZ) in units of degrees/s"]
    pub gyro: [f64; 3usize],
    #[doc = "< magnetometer (XYZ) in units of uT"]
    pub mag: [f64; 3usize],
    #[doc = "< thermometer, in units of degrees Celsius"]
    pub temp: f64,
    #[doc = "< raw gyroscope (XYZ)from 16-bit ADC"]
    pub raw_gyro: [i16; 3usize],
    #[doc = "< raw accelerometer (XYZ) from 16-bit ADC"]
    pub raw_accel: [i16; 3usize],
    pub __bindgen_padding_0: u32,
    #[doc = "< conversion rate from raw accelerometer to m/s^2"]
    pub accel_to_ms2: f64,
    #[doc = "< conversion rate from raw gyroscope to degrees/s"]
    pub gyro_to_degs: f64,
    #[doc = "< normalized quaternion from DMP based on ONLY Accel/Gyro"]
    pub dmp_quat: [f64; 4usize],
    #[doc = "< Tait-Bryan angles (roll pitch yaw) in radians from DMP based on ONLY Accel/Gyro"]
    pub dmp_TaitBryan: [f64; 3usize],
    #[doc = "< set to 1 if there was a tap detect on the last dmp sample, reset to 0 on next sample"]
    pub tap_detected: ::std::os::raw::c_int,
    #[doc = "< direction of last tap, 1-6 corresponding to X+ X- Y+ Y- Z+ Z-"]
    pub last_tap_direction: ::std::os::raw::c_int,
    #[doc = "< current counter of rapid consecutive taps"]
    pub last_tap_count: ::std::os::raw::c_int,
    pub __bindgen_padding_1: u32,
    #[doc = "< fused and normalized quaternion"]
    pub fused_quat: [f64; 4usize],
    #[doc = "< fused Tait-Bryan angles (roll pitch yaw) in radians"]
    pub fused_TaitBryan: [f64; 3usize],
    #[doc = "< fused heading filtered with gyro and accel data, same as Tait-Bryan yaw"]
    pub compass_heading: f64,
    #[doc = "< unfiltered heading from magnetometer"]
    pub compass_heading_raw: f64,
}
#[test]
fn bindgen_test_layout_rc_mpu_data_t() {
    assert_eq!(
        ::std::mem::size_of::<rc_mpu_data_t>(),
        256usize,
        concat!("Size of: ", stringify!(rc_mpu_data_t))
    );
    assert_eq!(
        ::std::mem::align_of::<rc_mpu_data_t>(),
        8usize,
        concat!("Alignment of ", stringify!(rc_mpu_data_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).accel as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(accel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).gyro as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(gyro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).mag as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(mag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).temp as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(temp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).raw_gyro as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(raw_gyro)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).raw_accel as *const _ as usize },
        86usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(raw_accel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).accel_to_ms2 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(accel_to_ms2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).gyro_to_degs as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(gyro_to_degs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).dmp_quat as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(dmp_quat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).dmp_TaitBryan as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(dmp_TaitBryan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).tap_detected as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(tap_detected)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_data_t>())).last_tap_direction as *const _ as usize
        },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(last_tap_direction)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).last_tap_count as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(last_tap_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).fused_quat as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(fused_quat)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).fused_TaitBryan as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(fused_TaitBryan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rc_mpu_data_t>())).compass_heading as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(compass_heading)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rc_mpu_data_t>())).compass_heading_raw as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rc_mpu_data_t),
            "::",
            stringify!(compass_heading_raw)
        )
    );
}
extern "C" {
    #[doc = " @brief      Returns an rc_mpu_config_t struct with default settings."]
    #[doc = ""]
    #[doc = " Use this as a starting point and modify as you wish."]
    #[doc = ""]
    #[doc = " @return     Returns an rc_mpu_config_t struct with default settings."]
    pub fn rc_mpu_default_config() -> rc_mpu_config_t;
}
extern "C" {
    #[doc = " @brief      Resets a config struct to defaults."]
    #[doc = ""]
    #[doc = " @param[out] conf  Pointer to config struct to be overwritten"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_set_config_to_default(conf: *mut rc_mpu_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Powers off the MPU"]
    #[doc = ""]
    #[doc = " Only call this after powering on the MPU with rc_mpu_initialize or"]
    #[doc = " rc_mpu_initialize_dmp. This should geenrally be called at the end of your"]
    #[doc = " main function to make sure the MPU is put to sleep."]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_power_off() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets up the MPU in normal one-shot sampling mode."]
    #[doc = ""]
    #[doc = " First create an instance of the rc_mpu_data_t struct and pass its pointer to"]
    #[doc = " rc_mpu_initialize which will then write to. Also pass an rc_mpu_config_t"]
    #[doc = " struct with your configruation settings."]
    #[doc = ""]
    #[doc = " This function will populate the  accel_to_ms2 and gyro_to_deg fields of the"]
    #[doc = " rc_mpu_data_t struct appropriately based on the user-configured full scale"]
    #[doc = " ranges."]
    #[doc = ""]
    #[doc = " After this, you may read sensor data at any time with the functions"]
    #[doc = " rc_mpu_read_accel(), rc_mpu_read_gyro(), and rc_mpu_read_temp(). The magentometer"]
    #[doc = " can also be read with rc_mpu_read_mag() if using an MPU9150 or MPU9250 and the"]
    #[doc = " enable_magnetometer field in the rc_mpu_config_t struct has been set to 1."]
    #[doc = ""]
    #[doc = " Be sure to power off the MPU at the end of your program with"]
    #[doc = " rc_mpu_power_off()."]
    #[doc = ""]
    #[doc = " @param      data  pointer to user's data struct"]
    #[doc = " @param[in]  conf  user congiguration data"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_initialize(
        data: *mut rc_mpu_data_t,
        conf: rc_mpu_config_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads accelerometer data from the MPU"]
    #[doc = ""]
    #[doc = " @param      data  Pointer to user's data struct where new data will be"]
    #[doc = " written"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_read_accel(data: *mut rc_mpu_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads gyroscope data from the MPU"]
    #[doc = ""]
    #[doc = " @param      data  Pointer to user's data struct where new data will be"]
    #[doc = " written"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_read_gyro(data: *mut rc_mpu_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads thermometer data from the MPU"]
    #[doc = ""]
    #[doc = " Note this is the internal termperature of the chip, not abient temperature."]
    #[doc = ""]
    #[doc = " @param      data  Pointer to user's data struct where new data will be"]
    #[doc = " written"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_read_temp(data: *mut rc_mpu_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads magnetometer data from the MPU"]
    #[doc = ""]
    #[doc = " Note this requires use of an MPU9150 or MPU9250, the MPU6050 and MPU6500 do"]
    #[doc = " not have magnetometers. Additionally, the enable_magnetometer flag must has"]
    #[doc = " been set in the user's rc_mpu_config_t when it was passed to"]
    #[doc = " rc_mpu_initialize()"]
    #[doc = ""]
    #[doc = " @param      data  Pointer to user's data struct where new data will be"]
    #[doc = " written"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_read_mag(data: *mut rc_mpu_data_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes the MPU in DMP mode, see rc_test_dmp example"]
    #[doc = ""]
    #[doc = " After calling this the user does not need to call the normal read functions"]
    #[doc = " rc_mpu_read_accel(), rc_mpu_read_gyro(), or rc_mpu_read mag(). Instead the"]
    #[doc = " data will automatically be read into the user's data struct at the"]
    #[doc = " dmp_sample_rate set in the config struct."]
    #[doc = ""]
    #[doc = " @param      data  Pointer to user's data struct where new data will be"]
    #[doc = " written"]
    #[doc = " @param[in]  conf  User's configuration struct"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_initialize_dmp(
        data: *mut rc_mpu_data_t,
        conf: rc_mpu_config_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the callback function that will be triggered when new DMP"]
    #[doc = " data is ready."]
    #[doc = ""]
    #[doc = " @param[in]  func  user's callback function"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_set_dmp_callback(
        func: ::std::option::Option<unsafe extern "C" fn()>,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      blocking function that returns once new DMP data is available"]
    #[doc = ""]
    #[doc = " @return     Returns 0 once new data is available, 1 if the MPU is shutting"]
    #[doc = " down due to rc_mpu_power_off, or -1 on error."]
    pub fn rc_mpu_block_until_dmp_data() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      calculates number of nanoseconds since the last DMP interrupt"]
    #[doc = ""]
    #[doc = " @return     nanoseconds since last interrupt, or -1 if no interrupt received"]
    #[doc = " yet."]
    pub fn rc_mpu_nanos_since_last_dmp_interrupt() -> i64;
}
extern "C" {
    #[doc = " @brief      sets the callback function triggered when a tap is detected"]
    #[doc = ""]
    #[doc = " @param[in]  func  user's callback function"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure."]
    pub fn rc_mpu_set_tap_callback(
        func: ::std::option::Option<
            unsafe extern "C" fn(direction: ::std::os::raw::c_int, counter: ::std::os::raw::c_int),
        >,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      blocking function that returns when a tap is detected"]
    #[doc = ""]
    #[doc = " @return     Returns 0 once a tap is detected, 1 if the MPU is shutting down"]
    #[doc = " due to rc_mpu_power_off(), or -1 on error."]
    pub fn rc_mpu_block_until_tap() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      calculates nanoseconds since last tap was detected"]
    #[doc = ""]
    #[doc = " @return     nanoseconds since last tap, or -1 if no tap has been detected"]
    #[doc = " yet."]
    pub fn rc_mpu_nanos_since_last_tap() -> i64;
}
extern "C" {
    #[doc = " @brief      Runs gyroscope calibration routine"]
    #[doc = ""]
    #[doc = " This should generally not be used by the user unless they absolutely want to"]
    #[doc = " calibrate the gyroscope inside their own program. Instead call the"]
    #[doc = " rc_calibrate_gyro example program."]
    #[doc = ""]
    #[doc = " @param[in]  conf  Config struct, only used to configure i2c bus and address."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_mpu_calibrate_gyro_routine(conf: rc_mpu_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Runs magnetometer calibration routine"]
    #[doc = ""]
    #[doc = " This should generally not be used by the user unless they absolutely want to"]
    #[doc = " calibrate the magnetometer inside their own program. Instead call the"]
    #[doc = " rc_calibrate_mag example program."]
    #[doc = ""]
    #[doc = " @param[in]  conf  Config struct, only used to configure i2c bus and address."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_mpu_calibrate_mag_routine(conf: rc_mpu_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Runs accelerometer calibration routine"]
    #[doc = ""]
    #[doc = " This should generally not be used by the user unless they absolutely want to"]
    #[doc = " calibrate the accelerometer inside their own program. Instead call the"]
    #[doc = " rc_calibrate_accel example program."]
    #[doc = ""]
    #[doc = " @param[in]  conf  Config struct, only used to configure i2c bus and address."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_mpu_calibrate_accel_routine(conf: rc_mpu_config_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Checks if a gyro calibration file is saved to disk"]
    #[doc = ""]
    #[doc = " generally used to warn the user that they are running a program without"]
    #[doc = " calibration. Can also be used to decide if calibration should be done at the"]
    #[doc = " beginning of user's program."]
    #[doc = ""]
    #[doc = " @return     1 if calibrated, 0 if not"]
    pub fn rc_mpu_is_gyro_calibrated() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Checks if a magnetometer calibration file is saved to disk"]
    #[doc = ""]
    #[doc = " generally used to warn the user that they are running a program without"]
    #[doc = " calibration. Can also be used to decide if calibration should be done at the"]
    #[doc = " beginning of user's program."]
    #[doc = ""]
    #[doc = " @return     1 if calibrated, 0 if not"]
    pub fn rc_mpu_is_mag_calibrated() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Checks if an accelerometer calibration file is saved to disk"]
    #[doc = ""]
    #[doc = " generally used to warn the user that they are running a program without"]
    #[doc = " calibration. Can also be used to decide if calibration should be done at the"]
    #[doc = " beginning of user's program."]
    #[doc = ""]
    #[doc = " @return     1 if calibrated, 0 if not"]
    pub fn rc_mpu_is_accel_calibrated() -> ::std::os::raw::c_int;
}
pub const rc_pinmux_mode_t_PINMUX_GPIO: rc_pinmux_mode_t = 0;
pub const rc_pinmux_mode_t_PINMUX_GPIO_PU: rc_pinmux_mode_t = 1;
pub const rc_pinmux_mode_t_PINMUX_GPIO_PD: rc_pinmux_mode_t = 2;
pub const rc_pinmux_mode_t_PINMUX_PWM: rc_pinmux_mode_t = 3;
pub const rc_pinmux_mode_t_PINMUX_SPI: rc_pinmux_mode_t = 4;
pub const rc_pinmux_mode_t_PINMUX_UART: rc_pinmux_mode_t = 5;
pub const rc_pinmux_mode_t_PINMUX_CAN: rc_pinmux_mode_t = 6;
#[doc = " Gives options for pinmuxing. Not every mode if available on each pin. Refer"]
#[doc = " to the official BeagleBone pin table for which to use."]
pub type rc_pinmux_mode_t = u32;
extern "C" {
    #[doc = " @brief      sets once of the pins defined in this header to a particular mode"]
    #[doc = ""]
    #[doc = " @param[in]  pin   The pin"]
    #[doc = " @param[in]  mode  The mode"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_pinmux_set(
        pin: ::std::os::raw::c_int,
        mode: rc_pinmux_mode_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      puts everything back to standard"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_pinmux_set_default() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Starts a single specified PRU core running a provided firmware name."]
    #[doc = ""]
    #[doc = " This function requires root privileges and your custom firmware must exist in"]
    #[doc = " \"/lib/firmware/\". The default name for the two firmwares are \"am335x-pru0-fw\""]
    #[doc = " and \"am335x-pru1-fw\", please don't overwrite these if they exist. Name your"]
    #[doc = " firmware image something like \"am335x-pru0-mycustom-fw\"."]
    #[doc = ""]
    #[doc = " @param[in]  ch       pru core to start (0 or 1)"]
    #[doc = " @param[in]  fw_name  The firmware image name, e.g. \"am335x-pru0-fw\", do not"]
    #[doc = " include '/lib/firmware' in the path, only the file name."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_pru_start(
        ch: ::std::os::raw::c_int,
        fw_name: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      fetches a pointer to the beginning of the PRU shared memory."]
    #[doc = ""]
    #[doc = " This is done by mapping to /dev/mem and therefore requires root privileges"]
    #[doc = " but provides extremely low-latency memory access to communicate with the PRU."]
    #[doc = ""]
    #[doc = " @return     memory pointer on success, NULL on failure"]
    pub fn rc_pru_shared_mem_ptr() -> *mut u32;
}
extern "C" {
    #[doc = " Unloads pru binaries"]
    #[doc = ""]
    #[doc = " @param[in]  ch    pru core to stop (0 or 1)"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_pru_stop(ch: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      starts a pthread with specified policy and priority"]
    #[doc = ""]
    #[doc = " Note that using anything other than SCHED_OTHER with priority 0 is only"]
    #[doc = " available to root users or after giving special permission to the executable"]
    #[doc = " with the setcap command line utility."]
    #[doc = ""]
    #[doc = " If a policy is selected which requires privaldges the user does not have,"]
    #[doc = " then a friendly warning will be displayed and the thread will still be set"]
    #[doc = " with the priority and scheduler inherited from the calling process."]
    #[doc = ""]
    #[doc = " @param      thread    pointer to user's pthread_t handle"]
    #[doc = " @param      func      function pointer for thread to start"]
    #[doc = " @param      arg       argument to pass to thread function when it starts"]
    #[doc = " @param[in]  policy    SCHED_FIFO SCHED_RR or SCHED_OTHER"]
    #[doc = " @param[in]  priority  between 1-99 for FIFO and RR, defualt 0 for SCHED_OTHER"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on error"]
    pub fn rc_pthread_create(
        thread: *mut pthread_t,
        func: ::std::option::Option<
            unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void) -> *mut ::std::os::raw::c_void,
        >,
        arg: *mut ::std::os::raw::c_void,
        policy: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Joins a thread with timeout given in seconds."]
    #[doc = ""]
    #[doc = " If no timeout is necessary, just use the standard system pthread_join"]
    #[doc = " function."]
    #[doc = ""]
    #[doc = " @param[in]  thread       pthread_t handle"]
    #[doc = " @param      retval       place to put the exit status of target thread, see"]
    #[doc = " pthread_join"]
    #[doc = " @param[in]  timeout_sec  floating point timeout in seconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if the thread joined within the timeout period, 1 if"]
    #[doc = " the thread timed out and was forced to close, -1 on error."]
    pub fn rc_pthread_timed_join(
        thread: pthread_t,
        retval: *mut *mut ::std::os::raw::c_void,
        timeout_sec: f32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Prints human-readable scheduler and priority for a pthread_t"]
    #[doc = " handle"]
    #[doc = ""]
    #[doc = " @param[in]  thread  pthread_t handle"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_pthread_print_properties(thread: pthread_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Lets a thread change it's own scheduler policy and priority while"]
    #[doc = " running"]
    #[doc = ""]
    #[doc = " @param[in]  policy    SCHED_FIFO SCHED_RR or SCHED_OTHER"]
    #[doc = " @param[in]  priority  between 1-99 for FIFO and RR, defualt 0 for SCHED_OTHER"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_pthread_set_properties_self(
        policy: ::std::os::raw::c_int,
        priority: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      fetches the niceness value of the executing process"]
    #[doc = ""]
    #[doc = " This is just a helpful wrapper for the system getpriority function and"]
    #[doc = " returns the same value."]
    #[doc = ""]
    #[doc = " @return     niceness (-20 to 20) or -1 on failure and sets errno"]
    pub fn rc_pthread_get_process_niceness() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Lets a process change its own niceness value"]
    #[doc = ""]
    #[doc = " Note that this requires special privaledges and will print an error if run by"]
    #[doc = " a normal user. This is just a helpful wrapper for the system setpriority"]
    #[doc = " funtion and returns the same thing."]
    #[doc = ""]
    #[doc = " @param[in]  niceness  new niceness (-20 to 20)"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_pthread_set_process_niceness(
        niceness: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Configures subsystem 0, 1, or 2 to operate at a particular"]
    #[doc = " frequency."]
    #[doc = ""]
    #[doc = " This may be called at runtime to change the pwm frequency without stopping"]
    #[doc = " the motors or pwm signal."]
    #[doc = ""]
    #[doc = " @param[in]  ss         Subsystem 0 1 or 2"]
    #[doc = " @param[in]  frequency  The frequency in HZ"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_pwm_init(
        ss: ::std::os::raw::c_int,
        frequency: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Stops a subsystem and puts it into a low-power state."]
    #[doc = ""]
    #[doc = " Recommended to call before userspace program exits to ensure the PWM hardware"]
    #[doc = " stops."]
    #[doc = ""]
    #[doc = " @param[in]  ss    subsystem 0,1,2"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_pwm_cleanup(ss: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the duty cycle of a specific pwm channel."]
    #[doc = ""]
    #[doc = " @param[in]  ss    subsystem 0,1,2"]
    #[doc = " @param[in]  ch    channel 'A' or 'B'"]
    #[doc = " @param[in]  duty  between 0.0 (off) and 1.0(full on)"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_pwm_set_duty(
        ss: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        duty: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Like rc_pwm_set_duty() but takes a pulse width in nanoseconds."]
    #[doc = ""]
    #[doc = " duty_ns which must range from 0 (off) to the number of nanoseconds in a"]
    #[doc = " single cycle as determined by the freqency specified when calling"]
    #[doc = " rc_pwm_init(). For example, a pwm frequency of 25kz corresponds to a maximum"]
    #[doc = " pulse width of 40,000ns."]
    #[doc = ""]
    #[doc = " @param[in]  ss       subsystem 0,1,2"]
    #[doc = " @param[in]  ch       channel 'A' or 'B'"]
    #[doc = " @param[in]  duty_ns  The duty cycle (pulse width) in nanoseconds"]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on failure."]
    pub fn rc_pwm_set_duty_ns(
        ss: ::std::os::raw::c_int,
        ch: ::std::os::raw::c_char,
        duty_ns: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Configures the PRU to send servo pulses"]
    #[doc = ""]
    #[doc = " Also leaves the servo power rail OFF, turn back on with"]
    #[doc = " rc_servo_power_rail_en(1) if you need to power servos off of the board."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Cleans up servo functionality and turns off the power rail."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_cleanup();
}
extern "C" {
    #[doc = " @brief      enables or disables the 6V power rail to drive servos."]
    #[doc = ""]
    #[doc = " The Robotics Cape has a 6V 4A high-efficiency switching regulator to power"]
    #[doc = " servos from the 2 cell LiPo battery. DO NOT enable this when using"]
    #[doc = " BEC-enabled brushless ESCs as it may damage them. Since brushless ESCs only"]
    #[doc = " need the ground and signal pins, it is safest to simply cut or disconnect the"]
    #[doc = " middle power wire. This will allow the use of servos and ESCs at the same"]
    #[doc = " time. Use the enable and disable functions above to control the power rail in"]
    #[doc = " software."]
    #[doc = ""]
    #[doc = " ALso use this to turn off power to the servos for example when the robot is"]
    #[doc = " in a paused state to save power or prevent noisy servos from buzzing."]
    #[doc = ""]
    #[doc = " @param[in]  en    0 to disable, non-zero to enable"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_power_rail_en(en: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sets the pulse width range used by the"]
    #[doc = " rc_servo_esc_send_pulse_normalized() function."]
    #[doc = ""]
    #[doc = " This function is not necessary when using the default range which is"]
    #[doc = " RC_ESC_DEFAULT_MIN_US (1000) to RC_ESC_DEFAULT_MAX_US (2000). This is only"]
    #[doc = " neccessary when using custom ranges. The most common need for this is when"]
    #[doc = " dealing with DJI motor drivers which cannot be calibrated. In this case use"]
    #[doc = " the line:"]
    #[doc = ""]
    #[doc = " rc_servo_set_esc_range(RC_ESC_DJI_MIN_US, RC_ESC_DJI_MAX_US);"]
    #[doc = ""]
    #[doc = " This will set the range to 1120-1920 for DJI motor drivers. Note that the"]
    #[doc = " minimum value is what is sent when calling rc_servo_usc_send_pulse_normalized"]
    #[doc = " with a desired motor control input of 0. A slightly negative value is still"]
    #[doc = " possible which will send a pulse width shorter than the minimum value given"]
    #[doc = " here. These negative values shoul dbe avoided with DJI motor drivers as they"]
    #[doc = " don't register."]
    #[doc = ""]
    #[doc = " @param[in]  min   The minimum pulse width in microseconds"]
    #[doc = " @param[in]  max   The maximum pulse width in microseconds"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure."]
    pub fn rc_servo_set_esc_range(
        min: ::std::os::raw::c_int,
        max: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sends a single pulse of desired width in microseconds to one or"]
    #[doc = " all channels."]
    #[doc = ""]
    #[doc = " This function returns right away and the PRU manages the accurate timing of"]
    #[doc = " the pulse in the background. Therefore calling this function succesively for"]
    #[doc = " each channel will start the pulse for each channel at approximately the same"]
    #[doc = " time."]
    #[doc = ""]
    #[doc = " As described above, servos and ESCs require regular pulses of at least 5hz to"]
    #[doc = " function. Since these pulses do not have to be accurate in frequency, the"]
    #[doc = " user can use these functions to start pulses from a userspace program at"]
    #[doc = " convenient locations in their program, such as immediately when new positions"]
    #[doc = " are calculated from sensor values."]
    #[doc = ""]
    #[doc = " @param[in]  ch    Channel to send signal to (1-8) or 0 to send to all"]
    #[doc = " channels."]
    #[doc = " @param[in]  us    Pulse Width in microseconds"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_send_pulse_us(
        ch: ::std::os::raw::c_int,
        us: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Like rc_send_pulse_us but translates a desired servo position"]
    #[doc = " from -1.5 to 1.5 to a corresponding pulse width from 600 to 2400us."]
    #[doc = ""]
    #[doc = " We cannot gurantee all servos will operate over the full range from -1.5 to"]
    #[doc = " 1.5 as that is normally considered the extended range. -1.0 to 1.0 is a more"]
    #[doc = " typical safe range but may not utilize the full range of all servos."]
    #[doc = ""]
    #[doc = " @param[in]  ch     Channel to send signal to (1-8) or 0 to send to all"]
    #[doc = " channels."]
    #[doc = " @param[in]  input  normalized position from -1.5 to 1.5"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_send_pulse_normalized(
        ch: ::std::os::raw::c_int,
        input: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Like rc_send_pulse_normalized but translates a desired esc"]
    #[doc = " throttle position from 0 to 1.0 to a corresponding pulse width from 1000 to"]
    #[doc = " 2000us."]
    #[doc = ""]
    #[doc = " This only works as expected if your ESCs are calibrated to accept pulse"]
    #[doc = " widths from 1000-2000us. This is best done with an ESC programming tool but"]
    #[doc = " can also be done with the rc_calibrate_escs example program that comes"]
    #[doc = " installed with this package."]
    #[doc = ""]
    #[doc = " While the normal operating range for the normalized input is 0.0 to 1.0,"]
    #[doc = " inputs as low as -0.1 are allowed. This is because many ESC firmwares such as"]
    #[doc = " BLHeli will still turn or chirp the motors at 0.0 throttle, but will be"]
    #[doc = " stationary and still armed and awake with throttle values slightly lower. We"]
    #[doc = " suggest using a throttle of -0.1 for at least a second at the beginnig of"]
    #[doc = " your program to wake the ESCs up from sleep but still keep the motors still."]
    #[doc = ""]
    #[doc = " @param[in]  ch     Channel to send signal to (1-8) or 0 to send to all"]
    #[doc = " channels."]
    #[doc = " @param[in]  input  normalized position from -0.1 to 1.0"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_send_esc_pulse_normalized(
        ch: ::std::os::raw::c_int,
        input: f64,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Like rc_send_pulse_normalized but translates a desired esc"]
    #[doc = " throttle position from 0 to 1.0 to a corresponding pulse width from 125 to"]
    #[doc = " 250us."]
    #[doc = ""]
    #[doc = " A recent trend among ESCs is support of \"One-Shot\" mode which shrinks the"]
    #[doc = " pulse range down to 125-250us for reduced latency. If you are sure your ESCs"]
    #[doc = " support this then you may try this function."]
    #[doc = ""]
    #[doc = " While the normal operating range for the normalized input is 0.0 to 1.0,"]
    #[doc = " inputs as low as -0.1 are allowed. This is because many ESC firmwares such as"]
    #[doc = " BLHeli will still turn or chirp the motors at 0.0 throttle, but will be"]
    #[doc = " stationary and still armed and awake with throttle values slightly lower. We"]
    #[doc = " suggest using a throttle of -0.1 for at least a second at the beginnig of"]
    #[doc = " your program to wake the ESCs up from sleep but still keep the motors still."]
    #[doc = ""]
    #[doc = " @param[in]  ch     Channel to send signal to (1-8) or 0 to send to all"]
    #[doc = " channels."]
    #[doc = " @param[in]  input  normalized position from -0.1 to 1.0"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_servo_send_oneshot_pulse_normalized(
        ch: ::std::os::raw::c_int,
        input: f64,
    ) -> ::std::os::raw::c_int;
}
pub type __s8 = ::std::os::raw::c_schar;
pub type __u8 = ::std::os::raw::c_uchar;
pub type __s16 = ::std::os::raw::c_short;
pub type __u16 = ::std::os::raw::c_ushort;
pub type __s32 = ::std::os::raw::c_int;
pub type __u32 = ::std::os::raw::c_uint;
pub type __s64 = ::std::os::raw::c_longlong;
pub type __u64 = ::std::os::raw::c_ulonglong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fd_set {
    pub fds_bits: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout___kernel_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fd_set>())).fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fd_set),
            "::",
            stringify!(fds_bits)
        )
    );
}
pub type __kernel_sighandler_t =
    ::std::option::Option<unsafe extern "C" fn(arg1: ::std::os::raw::c_int)>;
pub type __kernel_key_t = ::std::os::raw::c_int;
pub type __kernel_mqd_t = ::std::os::raw::c_int;
pub type __kernel_mode_t = ::std::os::raw::c_ushort;
pub type __kernel_ipc_pid_t = ::std::os::raw::c_ushort;
pub type __kernel_uid_t = ::std::os::raw::c_ushort;
pub type __kernel_gid_t = ::std::os::raw::c_ushort;
pub type __kernel_old_dev_t = ::std::os::raw::c_ushort;
pub type __kernel_long_t = ::std::os::raw::c_long;
pub type __kernel_ulong_t = ::std::os::raw::c_ulong;
pub type __kernel_ino_t = __kernel_ulong_t;
pub type __kernel_pid_t = ::std::os::raw::c_int;
pub type __kernel_suseconds_t = __kernel_long_t;
pub type __kernel_daddr_t = ::std::os::raw::c_int;
pub type __kernel_uid32_t = ::std::os::raw::c_uint;
pub type __kernel_gid32_t = ::std::os::raw::c_uint;
pub type __kernel_old_uid_t = __kernel_uid_t;
pub type __kernel_old_gid_t = __kernel_gid_t;
pub type __kernel_size_t = ::std::os::raw::c_uint;
pub type __kernel_ssize_t = ::std::os::raw::c_int;
pub type __kernel_ptrdiff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __kernel_fsid_t {
    pub val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___kernel_fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__kernel_fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__kernel_fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__kernel_fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__kernel_fsid_t>())).val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__kernel_fsid_t),
            "::",
            stringify!(val)
        )
    );
}
pub type __kernel_off_t = __kernel_long_t;
pub type __kernel_loff_t = ::std::os::raw::c_longlong;
pub type __kernel_time_t = __kernel_long_t;
pub type __kernel_clock_t = __kernel_long_t;
pub type __kernel_timer_t = ::std::os::raw::c_int;
pub type __kernel_clockid_t = ::std::os::raw::c_int;
pub type __kernel_caddr_t = *mut ::std::os::raw::c_char;
pub type __kernel_uid16_t = ::std::os::raw::c_ushort;
pub type __kernel_gid16_t = ::std::os::raw::c_ushort;
pub type __le16 = __u16;
pub type __be16 = __u16;
pub type __le32 = __u32;
pub type __be32 = __u32;
pub type __le64 = __u64;
pub type __be64 = __u64;
pub type __sum16 = __u16;
pub type __wsum = __u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct spi_ioc_transfer {
    pub tx_buf: __u64,
    pub rx_buf: __u64,
    pub len: __u32,
    pub speed_hz: __u32,
    pub delay_usecs: __u16,
    pub bits_per_word: __u8,
    pub cs_change: __u8,
    pub tx_nbits: __u8,
    pub rx_nbits: __u8,
    pub pad: __u16,
}
#[test]
fn bindgen_test_layout_spi_ioc_transfer() {
    assert_eq!(
        ::std::mem::size_of::<spi_ioc_transfer>(),
        32usize,
        concat!("Size of: ", stringify!(spi_ioc_transfer))
    );
    assert_eq!(
        ::std::mem::align_of::<spi_ioc_transfer>(),
        8usize,
        concat!("Alignment of ", stringify!(spi_ioc_transfer))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).tx_buf as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(tx_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).rx_buf as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(rx_buf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).speed_hz as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(speed_hz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).delay_usecs as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(delay_usecs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).bits_per_word as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(bits_per_word)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).cs_change as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(cs_change)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).tx_nbits as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(tx_nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).rx_nbits as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(rx_nbits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<spi_ioc_transfer>())).pad as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(spi_ioc_transfer),
            "::",
            stringify!(pad)
        )
    );
}
extern "C" {
    #[doc = " @brief      Initializes an SPI bus"]
    #[doc = ""]
    #[doc = " For description of the 4 SPI modes, see"]
    #[doc = " <https://en.wikipedia.org/wiki/Serial_Peripheral_Interface_Bus#Mode_numbers>"]
    #[doc = ""]
    #[doc = " @param[in]  bus       The bus"]
    #[doc = " @param[in]  slave     The slave"]
    #[doc = " @param[in]  bus_mode  SPI_MODE_0, SPI_MODE_1, SPI_MODE_2, or SPI_MODE_3"]
    #[doc = " @param[in]  speed_hz  The speed hz"]
    #[doc = ""]
    #[doc = " @return     0 on succcess or -1 on failure"]
    pub fn rc_spi_init_auto_slave(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        bus_mode: ::std::os::raw::c_int,
        speed_hz: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Initializes an SPI bus and GPIO pin for use as a manual SPI slave"]
    #[doc = " select pin."]
    #[doc = ""]
    #[doc = " The provided gpio chip/pin will then be remembered and tied to the provided"]
    #[doc = " slave number and bus. Note that on the BeagleBone and probably other"]
    #[doc = " platforms, there are only two files provided by the driver for interfacing to"]
    #[doc = " the bus, /dev/spi1.0 and /dev/spi1.1. When using a slave in manual mode, the"]
    #[doc = " first interface (slave 0 in software) will be used to talk to the manual"]
    #[doc = " slaves. Therefore this slave can not be used as an automatic slave."]
    #[doc = ""]
    #[doc = " For the BeagleBone Blue and RoboticsCape, this will also ensure that the"]
    #[doc = " pinmux is set correctly for that pin. The available manual slave select pins"]
    #[doc = " for these two boards are defined in this header for convenience. If using"]
    #[doc = " other boards it's up to the user to make sure the pin they are using is set"]
    #[doc = " up correctly in the device tree."]
    #[doc = ""]
    #[doc = " @param[in]  bus       The spi bus"]
    #[doc = " @param[in]  slave     The slave identifier (up to 16)"]
    #[doc = " @param[in]  bus_mode  The bus mode"]
    #[doc = " @param[in]  speed_hz  The speed hz"]
    #[doc = " @param[in]  chip      The gpio chip"]
    #[doc = " @param[in]  pin       The gpio pin"]
    #[doc = ""]
    #[doc = " @return     0 on succcess or -1 on failure"]
    pub fn rc_spi_init_manual_slave(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        bus_mode: ::std::os::raw::c_int,
        speed_hz: ::std::os::raw::c_int,
        chip: ::std::os::raw::c_int,
        pin: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      fetches the file descriptor for a specified slave so the user can"]
    #[doc = " do more advanced IO operations than what's presented here"]
    #[doc = ""]
    #[doc = " @param[in]  bus    The bus"]
    #[doc = " @param[in]  slave  0 or 1"]
    #[doc = ""]
    #[doc = " @return     fd or -1 on failure"]
    pub fn rc_spi_get_fd(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Closes and cleans up the bus for specified slave"]
    #[doc = ""]
    #[doc = " @param[in]  bus   SPI bus to close"]
    #[doc = ""]
    #[doc = " @return     0 on succcess or -1 on failure"]
    pub fn rc_spi_close(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Manually selects or deselects a slave"]
    #[doc = ""]
    #[doc = " Only works if slave was initialized with SPI_SLAVE_MODE_MANUAL. If"]
    #[doc = " SPI_SLAVE_MODE_AUTO was selected then the SPI driver will handle this"]
    #[doc = " automatically when reading or writing."]
    #[doc = ""]
    #[doc = " @param[in]  bus     SPI bus to use"]
    #[doc = " @param[in]  slave   slave id"]
    #[doc = " @param[in]  select  0 to deselect, otherwise selects"]
    #[doc = ""]
    #[doc = " @return     0 on succcess or -1 on failure"]
    pub fn rc_spi_manual_select(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        select: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Send any sequence of bytes and read the response."]
    #[doc = ""]
    #[doc = " This is a wrapper for the ioctl spi transfer function and is generally what"]
    #[doc = " you will use for reading/writing device registers."]
    #[doc = ""]
    #[doc = " @param[in]  bus       SPI bus to use"]
    #[doc = " @param[in]  slave     slave id"]
    #[doc = " @param[in]  tx_data   pointer to data to send"]
    #[doc = " @param[in]  tx_bytes  number of bytes to send"]
    #[doc = " @param      rx_data   pointer to put response data"]
    #[doc = ""]
    #[doc = " @return     number of bytes received or -1 on failure"]
    pub fn rc_spi_transfer(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        tx_data: *mut u8,
        tx_bytes: usize,
        rx_data: *mut u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Writes data to specified slave"]
    #[doc = ""]
    #[doc = " @param[in]  bus    SPI bus to use"]
    #[doc = " @param[in]  slave  slave id"]
    #[doc = " @param      data   data pointer"]
    #[doc = " @param[in]  bytes  number of bytes to send"]
    #[doc = ""]
    #[doc = " @return     returns number of bytes written or -1 on failure"]
    pub fn rc_spi_write(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        data: *mut u8,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Reads data from a specified slave"]
    #[doc = ""]
    #[doc = " @param[in]  bus    SPI bus to use"]
    #[doc = " @param[in]  slave  slave id"]
    #[doc = " @param      data   data poitner"]
    #[doc = " @param[in]  bytes  number of bytes to read"]
    #[doc = ""]
    #[doc = " @return     number of bytes read or -1 on failure"]
    pub fn rc_spi_read(
        bus: ::std::os::raw::c_int,
        slave: ::std::os::raw::c_int,
        data: *mut u8,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
pub const rc_state_t_UNINITIALIZED: rc_state_t = 0;
pub const rc_state_t_RUNNING: rc_state_t = 1;
pub const rc_state_t_PAUSED: rc_state_t = 2;
pub const rc_state_t_EXITING: rc_state_t = 3;
#[doc = " @brief      process state variable, read and modify by rc_get_state,"]
#[doc = " rc_set_state, and rc_print_state. Starts as UNINITIALIZED."]
pub type rc_state_t = u32;
extern "C" {
    #[doc = " @brief      fetches the current process state as set by the user or signal"]
    #[doc = " handler"]
    #[doc = ""]
    #[doc = " @return     current process state"]
    pub fn rc_get_state() -> rc_state_t;
}
extern "C" {
    #[doc = " @brief      sets the current process state."]
    #[doc = ""]
    #[doc = " Except for the signal handler setting the state to EXITING, this is the only"]
    #[doc = " way that the process state can be changed."]
    #[doc = ""]
    #[doc = " @param[in]  new_state  The new state"]
    pub fn rc_set_state(new_state: rc_state_t);
}
extern "C" {
    #[doc = " @brief      prints the process state to stdout in human-readble form"]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_print_state() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Makes a PID file RC_PID_FILE (/run/shm/robotcontrol.pid)"]
    #[doc = " containing the current PID of your process"]
    #[doc = ""]
    #[doc = " @return     Returns 0 if successful. If that file already exists then it is"]
    #[doc = " not touched and this function returns 1 at which point we suggest you run"]
    #[doc = " rc_kill_exising_process() to kill that process. Returns -1 if there is some"]
    #[doc = " other problem writing to the file."]
    pub fn rc_make_pid_file() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      This function is used to make sure any existing program using the"]
    #[doc = " PID file is stopped."]
    #[doc = ""]
    #[doc = " The user doesn't need to integrate this in their own program However, the"]
    #[doc = " user may call the rc_kill example program from the command line to close"]
    #[doc = " whatever program is running in the background."]
    #[doc = ""]
    #[doc = " @param[in]  timeout_s  timeout period to wait for process to close cleanly,"]
    #[doc = " must be >=0.1"]
    #[doc = ""]
    #[doc = " @return     return values:"]
    #[doc = " - -4: invalid argument or other error"]
    #[doc = " - -3: insufficient privileges to kill existing process"]
    #[doc = " - -2: unreadable or invalid contents in RC_PID_FILE"]
    #[doc = " - -1: existing process failed to close cleanly and had to be killed"]
    #[doc = " -  0: No existing process was running"]
    #[doc = " -  1: An existing process was running but it shut down cleanly."]
    pub fn rc_kill_existing_process(timeout_s: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Removes the PID file created by rc_make_pid_file()."]
    #[doc = ""]
    #[doc = " This should be called before your program closes to make sure it's not left"]
    #[doc = " behind."]
    #[doc = ""]
    #[doc = " @return     Returns 0 whether or not the file was actually there. Returns -1"]
    #[doc = " if there was a file system error."]
    pub fn rc_remove_pid_file() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Enables a generic signal handler. Optional but recommended."]
    #[doc = ""]
    #[doc = " This catches SIGINT, SIGTERM, SIGHUP, and SIGSEGV and does the following:"]
    #[doc = ""]
    #[doc = " - SIGINT (ctrl-c) Sets process state to EXITING indicating to the user"]
    #[doc = "   threads to shut down cleanly. All user threads should check rc_get_state to"]
    #[doc = "   catch this."]
    #[doc = " - SITERM: Same as SIGINT above"]
    #[doc = " - SIGHUP: Ignored to prevent process from stopping due to loose USB network"]
    #[doc = "   connection. Also allows robot control programs to keep running after USB"]
    #[doc = "   cable in intentionally removed."]
    #[doc = " - SIGSEGV:  Segfaults will be caught and print some debugging info to the"]
    #[doc = "   screen before setting rc_state to EXITING. Behavior with segfaults is no"]
    #[doc = "   guaranteed to be predictable."]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on error"]
    pub fn rc_enable_signal_handler() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      resets the system signal callbacks to defualt, generally this is"]
    #[doc = " never needed unless you are intentionally changing signal handlers in the"]
    #[doc = " middle of a program."]
    #[doc = ""]
    #[doc = " @return     Returns 0 on success or -1 on error"]
    pub fn rc_disable_signal_handler() -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __time_t,
    pub tv_usec: __suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        8usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        4usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type __sig_atomic_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __sigset_t {
    pub __val: [::std::os::raw::c_ulong; 32usize],
}
#[test]
fn bindgen_test_layout___sigset_t() {
    assert_eq!(
        ::std::mem::size_of::<__sigset_t>(),
        128usize,
        concat!("Size of: ", stringify!(__sigset_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigset_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__sigset_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__sigset_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigset_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type sigset_t = __sigset_t;
pub type suseconds_t = __suseconds_t;
pub type __fd_mask = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct fd_set {
    pub __fds_bits: [__fd_mask; 32usize],
}
#[test]
fn bindgen_test_layout_fd_set() {
    assert_eq!(
        ::std::mem::size_of::<fd_set>(),
        128usize,
        concat!("Size of: ", stringify!(fd_set))
    );
    assert_eq!(
        ::std::mem::align_of::<fd_set>(),
        4usize,
        concat!("Alignment of ", stringify!(fd_set))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<fd_set>())).__fds_bits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(fd_set),
            "::",
            stringify!(__fds_bits)
        )
    );
}
pub type fd_mask = __fd_mask;
extern "C" {
    pub fn select(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *mut timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pselect(
        __nfds: ::std::os::raw::c_int,
        __readfds: *mut fd_set,
        __writefds: *mut fd_set,
        __exceptfds: *mut fd_set,
        __timeout: *const timespec,
        __sigmask: *const __sigset_t,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timezone {
    pub tz_minuteswest: ::std::os::raw::c_int,
    pub tz_dsttime: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_timezone() {
    assert_eq!(
        ::std::mem::size_of::<timezone>(),
        8usize,
        concat!("Size of: ", stringify!(timezone))
    );
    assert_eq!(
        ::std::mem::align_of::<timezone>(),
        4usize,
        concat!("Alignment of ", stringify!(timezone))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_minuteswest as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_minuteswest)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timezone>())).tz_dsttime as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(timezone),
            "::",
            stringify!(tz_dsttime)
        )
    );
}
pub type __timezone_ptr_t = *mut timezone;
extern "C" {
    pub fn gettimeofday(__tv: *mut timeval, __tz: __timezone_ptr_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn settimeofday(__tv: *const timeval, __tz: *const timezone) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn adjtime(__delta: *const timeval, __olddelta: *mut timeval) -> ::std::os::raw::c_int;
}
pub const __itimer_which_ITIMER_REAL: __itimer_which = 0;
pub const __itimer_which_ITIMER_VIRTUAL: __itimer_which = 1;
pub const __itimer_which_ITIMER_PROF: __itimer_which = 2;
pub type __itimer_which = u32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct itimerval {
    pub it_interval: timeval,
    pub it_value: timeval,
}
#[test]
fn bindgen_test_layout_itimerval() {
    assert_eq!(
        ::std::mem::size_of::<itimerval>(),
        16usize,
        concat!("Size of: ", stringify!(itimerval))
    );
    assert_eq!(
        ::std::mem::align_of::<itimerval>(),
        4usize,
        concat!("Alignment of ", stringify!(itimerval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_interval as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_interval)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<itimerval>())).it_value as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(itimerval),
            "::",
            stringify!(it_value)
        )
    );
}
pub type __itimer_which_t = ::std::os::raw::c_int;
extern "C" {
    pub fn getitimer(__which: __itimer_which_t, __value: *mut itimerval) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setitimer(
        __which: __itimer_which_t,
        __new: *const itimerval,
        __old: *mut itimerval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn utimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lutimes(
        __file: *const ::std::os::raw::c_char,
        __tvp: *const timeval,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn futimes(__fd: ::std::os::raw::c_int, __tvp: *const timeval) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sleep in nanoseconds"]
    #[doc = ""]
    #[doc = " A wrapper for the normal UNIX nanosleep function which takes a number of"]
    #[doc = " nanoseconds instead of a timeval struct. This also handles restarting"]
    #[doc = " nanosleep with the remaining time in the event that nanosleep is interrupted"]
    #[doc = " by a signal. There is no upper limit on the time requested."]
    #[doc = ""]
    #[doc = " @param[in]  ns    nanoseconds to sleep"]
    pub fn rc_nanosleep(ns: u64);
}
extern "C" {
    #[doc = " @brief      Sleep in microseconds"]
    #[doc = ""]
    #[doc = " The traditional usleep function, however common, is deprecated in linux as it"]
    #[doc = " uses SIGALARM which interferes with alarm and timer functions. This uses the"]
    #[doc = " new POSIX standard nanosleep to accomplish the same thing which further"]
    #[doc = " supports sleeping for lengths longer than 1 second. This also handles"]
    #[doc = " restarting nanosleep with the remaining time in the event that nanosleep is"]
    #[doc = " interrupted by a signal. There is no upper limit on the time requested."]
    #[doc = ""]
    #[doc = " @param[in]  us    microseconds to sleep"]
    pub fn rc_usleep(us: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " @brief      Returns the number of nanoseconds since epoch using system"]
    #[doc = " CLOCK_REALTIME"]
    #[doc = ""]
    #[doc = " This function itself takes about 1100ns to complete on a beaglebone at 1ghz"]
    #[doc = " under ideal circumstances."]
    #[doc = ""]
    #[doc = " @return     nanoseconds since epoch"]
    pub fn rc_nanos_since_epoch() -> u64;
}
extern "C" {
    #[doc = " @brief      Returns the number of nanoseconds since system boot using"]
    #[doc = " CLOCK_MONOTONIC"]
    #[doc = ""]
    #[doc = " This function itself takes about 1100ns to complete on a bealgebone at 1ghz"]
    #[doc = " under ideal circumstances."]
    #[doc = ""]
    #[doc = " @return     nanoseconds since system boot"]
    pub fn rc_nanos_since_boot() -> u64;
}
extern "C" {
    #[doc = " @brief      Returns the number of nanoseconds from when when the calling"]
    #[doc = " thread was started in CPU time."]
    #[doc = ""]
    #[doc = " This uses CLOCK_THREAD_CPUTIME_ID. This time only increments when the"]
    #[doc = " processor is working on the calling thread and not when the thread is"]
    #[doc = " sleeping. This is usually for timing how long blocks of user-code take to"]
    #[doc = " execute. This function itself takes about 2100ns to complete on a beaglebone"]
    #[doc = " at 1ghz under ideal circumstances."]
    #[doc = ""]
    #[doc = " @return     nanoseconds of CPU time since thread started"]
    pub fn rc_nanos_thread_time() -> u64;
}
extern "C" {
    #[doc = " @brief      Returns a number of microseconds corresponding to a timespec"]
    #[doc = " struct."]
    #[doc = ""]
    #[doc = " Useful because timespec structs are annoying."]
    #[doc = ""]
    #[doc = " @param[in]  ts    timespec struct to convert"]
    #[doc = ""]
    #[doc = " @return     time in microseconds"]
    pub fn rc_timespec_to_micros(ts: timespec) -> u64;
}
extern "C" {
    #[doc = " @brief      Returns a number of milliseconds corresponding to a timespec"]
    #[doc = " struct."]
    #[doc = ""]
    #[doc = " Useful because timespec structs are annoying."]
    #[doc = ""]
    #[doc = " @param[in]  ts    timespec struct to convert"]
    #[doc = ""]
    #[doc = " @return     time in milliseconds"]
    pub fn rc_timespec_to_millis(ts: timespec) -> u64;
}
extern "C" {
    #[doc = " @brief      Returns a number of microseconds corresponding to a timeval"]
    #[doc = " struct."]
    #[doc = ""]
    #[doc = " Useful because timeval structs are annoying."]
    #[doc = ""]
    #[doc = " @param[in]  tv    timeval struct to convert"]
    #[doc = ""]
    #[doc = " @return     time in microseconds"]
    pub fn rc_timeval_to_micros(tv: timeval) -> u64;
}
extern "C" {
    #[doc = " @brief      Returns a number of milliseconds corresponding to a timeval"]
    #[doc = " struct."]
    #[doc = ""]
    #[doc = " Useful because timespec structs are annoying."]
    #[doc = ""]
    #[doc = " @param[in]  tv    timeval struct to convert"]
    #[doc = ""]
    #[doc = " @return     time in microseconds"]
    pub fn rc_timeval_to_millis(tv: timeval) -> u64;
}
extern "C" {
    #[doc = " @brief      Returns the time difference between two timespec structs as"]
    #[doc = " another timespec."]
    #[doc = ""]
    #[doc = ""]
    #[doc = " Convenient for use with nanosleep() function and accurately timed loops."]
    #[doc = " Unlike timespec_sub defined in time.h, rc_timespec_diff does not care which"]
    #[doc = " came first, A or B. A positive difference in time is always returned."]
    #[doc = ""]
    #[doc = " @param[in]  A     timespec struct"]
    #[doc = " @param[in]  B     timespec struct"]
    #[doc = ""]
    #[doc = " @return     timespec struct of the difference, always positive"]
    pub fn rc_timespec_diff(A: timespec, B: timespec) -> timespec;
}
extern "C" {
    #[doc = " @brief      Adds an amount of time in seconds to a timespec struct."]
    #[doc = ""]
    #[doc = " The time added is a double-precision floating point value to make"]
    #[doc = " respresenting fractions of a second easier. The timespec is passed as a"]
    #[doc = " pointer so it can be modified in place. Seconds may be negative."]
    #[doc = ""]
    #[doc = " @param      start    The start timspec, modified in place"]
    #[doc = " @param[in]  seconds  The seconds"]
    pub fn rc_timespec_add(start: *mut timespec, seconds: f64);
}
extern "C" {
    #[doc = " @brief      Initializes a UART bus /dev/ttyO{bus} at specified baudrate and"]
    #[doc = " timeout."]
    #[doc = ""]
    #[doc = " This is a very generalized function that configures the bus for 8-bit"]
    #[doc = " characters and ignores the modem status lines."]
    #[doc = ""]
    #[doc = " If you need a configuration other than whats presented here then you are"]
    #[doc = " probably doing something fancy with the bus and you will probably want to do"]
    #[doc = " your own reading/writing with standard linux methods."]
    #[doc = ""]
    #[doc = " @param[in]  bus           The bus number /dev/ttyO{bus}"]
    #[doc = " @param[in]  baudrate      must be one of the standard speeds in the UART"]
    #[doc = " spec. 115200 and 57600 are most common."]
    #[doc = " @param[in]  timeout       timeout is in seconds and must be >=0.1"]
    #[doc = " @param[in]  canonical_en  0 for non-canonical mode (raw data), non-zero for"]
    #[doc = " canonical mode where only one line ending in '\\n' is read at a time."]
    #[doc = " @param[in]  stop_bits     number of stop bits, 1 or 2, usually 1 for most"]
    #[doc = " sensors"]
    #[doc = " @param[in]  parity_en     0 to disable parity, nonzero to enable. usually"]
    #[doc = " disabled for most sensors."]
    #[doc = ""]
    #[doc = " @return     0 on success, -1 on failure"]
    pub fn rc_uart_init(
        bus: ::std::os::raw::c_int,
        baudrate: ::std::os::raw::c_int,
        timeout: f32,
        canonical_en: ::std::os::raw::c_int,
        stop_bits: ::std::os::raw::c_int,
        parity_en: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      closes a UART bus"]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus number /dev/ttyO{bus}"]
    #[doc = ""]
    #[doc = " @return     returns 0 on success, -1 on error."]
    pub fn rc_uart_close(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fetches the file descriptor to a uart bus after the bus has been"]
    #[doc = " initialized."]
    #[doc = ""]
    #[doc = " This is so the user can optionally do additional configuration or IO"]
    #[doc = " operations on the bus."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus number /dev/ttyO{bus}"]
    #[doc = ""]
    #[doc = " @return     the file descriptor to /dev/ttyO{bus} or -1 on error"]
    pub fn rc_uart_get_fd(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      flushes (discards) any data received but not read, or data"]
    #[doc = " written but not sent."]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus number /dev/ttyO{bus}"]
    #[doc = ""]
    #[doc = " @return     0 on success or -1 on failure"]
    pub fn rc_uart_flush(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Sends data out the uart port"]
    #[doc = ""]
    #[doc = " @param[in]  bus    The bus number /dev/ttyO{bus}"]
    #[doc = " @param[in]  data   data pointer"]
    #[doc = " @param[in]  bytes  number of bytes to send"]
    #[doc = ""]
    #[doc = " @return     returns number of bytes sent or -1 on error"]
    pub fn rc_uart_write(
        bus: ::std::os::raw::c_int,
        data: *mut u8,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      reads bytes from the UART bus"]
    #[doc = ""]
    #[doc = " This is a blocking function call. It will only return once the desired number"]
    #[doc = " of bytes has been read from the buffer or the shutdown flag is set. due to"]
    #[doc = " the Sitara's UART FIFO buffer, MAX_READ_LEN (128bytes) is the largest packet"]
    #[doc = " that can be read with a single call to read(). For reads larger than"]
    #[doc = " 128bytes, we run a loop instead."]
    #[doc = ""]
    #[doc = " @param[in]  bus    The bus number /dev/ttyO{bus}"]
    #[doc = " @param[out] buf    data pointer"]
    #[doc = " @param[in]  bytes  number of bytes to read"]
    #[doc = ""]
    #[doc = " @return     Returns number of bytes actually read or -1 on error."]
    pub fn rc_uart_read_bytes(
        bus: ::std::os::raw::c_int,
        buf: *mut u8,
        bytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      reads a line of characters ending in newline '\\n'"]
    #[doc = ""]
    #[doc = " This is a blocking function call. It will only return on these conditions:"]
    #[doc = ""]
    #[doc = " - a newline character was read, this is discarded."]
    #[doc = " - max_bytes were read, this prevents overflowing a user buffer."]
    #[doc = " - timeout declared in rc_uart_init() is reached"]
    #[doc = " - shutdown flag is set by rc_uart_close"]
    #[doc = ""]
    #[doc = " @param[in]  bus        The bus number /dev/ttyO{bus}"]
    #[doc = " @param[out] buf        data pointer"]
    #[doc = " @param[in]  max_bytes  max bytes to read in case newline character not found"]
    #[doc = ""]
    #[doc = " @return     Returns number of bytes actually read or -1 on error."]
    pub fn rc_uart_read_line(
        bus: ::std::os::raw::c_int,
        buf: *mut u8,
        max_bytes: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      Fetches the number of bytes ready to be read from a bus"]
    #[doc = ""]
    #[doc = " @param[in]  bus   The bus"]
    #[doc = ""]
    #[doc = " @return     Returns number of bytes ready to be read or -1 on error."]
    pub fn rc_uart_bytes_available(bus: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " @brief      get an integer representation of the library version"]
    #[doc = ""]
    #[doc = " 8 bits are used for each component, with the patch number stored in the 8"]
    #[doc = " least significant bits. E.g. for version 1.2.3 this would be 0x010203."]
    #[doc = ""]
    #[doc = " @return     integer representation of the library version"]
    pub fn rc_version() -> ::std::os::raw::c_uint;
}
extern "C" {
    #[doc = " @brief      gets a string representation of the current library version."]
    #[doc = ""]
    #[doc = " @return     const char* string"]
    pub fn rc_version_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " @brief      prints a string representation of the current library version to"]
    #[doc = " stdout with no trailing newline character."]
    pub fn rc_version_print();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_data {
    pub _address: u8,
}
